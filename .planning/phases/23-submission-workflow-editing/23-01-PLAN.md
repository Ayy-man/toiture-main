---
phase: 23-submission-workflow-editing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/sql/create_submissions_table.sql
  - backend/app/schemas/submission.py
  - backend/app/services/submission_service.py
  - backend/app/models/upsell_rules.json
  - backend/app/routers/submissions.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "POST /submissions creates a draft submission from hybrid quote data"
    - "GET /submissions/{id} returns full submission with line_items, notes, audit_log"
    - "PATCH /submissions/{id} updates line_items and recalculates totals (draft only)"
    - "POST /submissions/{id}/finalize transitions status from draft to pending_approval"
    - "POST /submissions/{id}/approve requires admin role header and transitions to approved"
    - "POST /submissions/{id}/reject requires admin role header and transitions to rejected"
    - "POST /submissions/{id}/return-to-draft transitions rejected or pending_approval back to draft"
    - "POST /submissions/{id}/notes adds timestamped attributed note"
    - "POST /submissions/{id}/upsells creates child submission linked to parent"
    - "GET /submissions/{id}/upsell-suggestions returns category-specific upsell options"
    - "Invalid status transitions return 400 error"
    - "Non-admin users get 403 on approve/reject endpoints"
  artifacts:
    - path: "backend/sql/create_submissions_table.sql"
      provides: "PostgreSQL DDL for submissions table with status, JSONB, indexes, trigger"
      contains: "CREATE TABLE submissions"
    - path: "backend/app/schemas/submission.py"
      provides: "Pydantic models for submission CRUD and workflow"
      exports: ["SubmissionStatus", "VALID_TRANSITIONS", "LineItem", "Note", "AuditEntry", "SubmissionCreate", "SubmissionUpdate", "SubmissionResponse", "SubmissionListItem", "NoteCreate", "UpsellCreate"]
    - path: "backend/app/services/submission_service.py"
      provides: "Business logic for submission CRUD, state machine, notes, audit, upsells"
      exports: ["create_submission", "get_submission", "list_submissions", "update_submission", "finalize_submission", "approve_submission", "reject_submission", "return_to_draft_submission", "add_note", "create_upsell_submission", "get_upsell_suggestions"]
    - path: "backend/app/models/upsell_rules.json"
      provides: "Bilingual upsell rule config mapping category to suggested services"
      contains: "Bardeaux"
    - path: "backend/app/routers/submissions.py"
      provides: "FastAPI endpoints for submission workflow with role-based access"
      exports: ["router"]
    - path: "backend/app/main.py"
      provides: "Updated main app with submissions router registered"
      contains: "submissions.router"
  key_links:
    - from: "backend/app/routers/submissions.py"
      to: "backend/app/services/submission_service.py"
      via: "service function calls"
      pattern: "from app\\.services\\.submission_service import"
    - from: "backend/app/services/submission_service.py"
      to: "Supabase submissions table"
      via: "get_supabase() client"
      pattern: "get_supabase\\(\\)"
    - from: "backend/app/main.py"
      to: "backend/app/routers/submissions.py"
      via: "app.include_router registration"
      pattern: "include_router\\(submissions\\.router\\)"
    - from: "backend/app/services/submission_service.py"
      to: "backend/app/models/upsell_rules.json"
      via: "json.load for upsell suggestions"
      pattern: "upsell_rules\\.json"
---

<objective>
Create the complete backend for the submission workflow: database schema (SQL DDL), Pydantic models with state machine, service layer with CRUD/workflow/notes/audit/upsell operations, FastAPI router with 11 endpoints, upsell rules JSON config, and main.py registration.

Purpose: This is the data and API foundation for editable submissions with approval workflow. The frontend (Plan 23-02) consumes these endpoints. Phase 24 (Export/Send) also depends on submission status.

Output: SQL DDL file, 4 new Python modules, 1 JSON config, updated main.py. Backend ready for frontend integration.
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-submission-workflow-editing/23-RESEARCH.md
@backend/app/schemas/hybrid_quote.py
@backend/app/routers/estimate.py
@backend/app/services/supabase_client.py
@backend/app/main.py
@frontend/src/lib/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL DDL, Pydantic schemas, upsell rules JSON, and service layer</name>
  <files>
    backend/sql/create_submissions_table.sql
    backend/app/schemas/submission.py
    backend/app/services/submission_service.py
    backend/app/models/upsell_rules.json
  </files>
  <action>
**1. Create `backend/sql/create_submissions_table.sql`:**

SQL migration for Supabase SQL editor. Create `submissions` table:

```sql
CREATE TABLE IF NOT EXISTS submissions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL,
  estimate_id uuid,
  created_by text,
  status text NOT NULL DEFAULT 'draft',
  finalized_at timestamptz,
  approved_at timestamptz,
  approved_by text,
  client_name text,
  category text NOT NULL,
  sqft numeric(10,2),
  line_items jsonb NOT NULL DEFAULT '[]'::jsonb,
  notes jsonb DEFAULT '[]'::jsonb,
  audit_log jsonb DEFAULT '[]'::jsonb,
  parent_submission_id uuid REFERENCES submissions(id) ON DELETE CASCADE,
  upsell_type text,
  pricing_tiers jsonb NOT NULL DEFAULT '[]'::jsonb,
  selected_tier text DEFAULT 'Standard',
  total_materials_cost numeric(10,2) NOT NULL DEFAULT 0,
  total_labor_cost numeric(10,2) NOT NULL DEFAULT 0,
  total_price numeric(10,2) NOT NULL DEFAULT 0,
  CONSTRAINT valid_status CHECK (status IN ('draft', 'pending_approval', 'approved', 'rejected')),
  CONSTRAINT valid_tier CHECK (selected_tier IN ('Basic', 'Standard', 'Premium'))
);
```

Add indexes: `status`, `created_at DESC`, `parent_submission_id WHERE NOT NULL`, `estimate_id`, GIN on `notes`, GIN on `audit_log`.

Add `update_updated_at_column()` function (CREATE OR REPLACE, IF NOT EXISTS safe) and trigger on submissions.

Also: `ALTER TABLE estimates ADD COLUMN IF NOT EXISTS submission_created boolean DEFAULT false;`

**2. Create `backend/app/schemas/submission.py`:**

Follow the exact pattern from `backend/app/schemas/hybrid_quote.py` (Pydantic BaseModel, Field, Literal, field_validator, model_validator).

Models to create:

- `SubmissionStatus(str, Enum)`: draft, pending_approval, approved, rejected
- `VALID_TRANSITIONS` dict:
  - draft -> [pending_approval]
  - pending_approval -> [approved, rejected, draft]
  - approved -> [] (terminal)
  - rejected -> [draft]
- `LineItem(BaseModel)`: id (str), type (Literal["material", "labor"]), material_id (Optional[int]), name (str), quantity (float, gt=0), unit_price (float, ge=0), total (float, ge=0), order (int, ge=0). Add field_validator on total to check it matches quantity * unit_price within 0.01 tolerance (same pattern as MaterialLineItem in hybrid_quote.py).
- `Note(BaseModel)`: id (str), text (str), created_by (str), created_at (str)
- `AuditEntry(BaseModel)`: action (str), user (str), timestamp (str), changes (Optional[dict]), reason (Optional[str])
- `SubmissionCreate(BaseModel)`: category (str), sqft (Optional[float]), client_name (Optional[str]), created_by (Optional[str]), line_items (List[LineItem]), pricing_tiers (list), selected_tier (str, default="Standard"), estimate_id (Optional[str]). Add model_validator to compute total_materials_cost, total_labor_cost, total_price from line_items.
- `SubmissionUpdate(BaseModel)`: line_items (Optional[List[LineItem]]), selected_tier (Optional[str]), client_name (Optional[str])
- `NoteCreate(BaseModel)`: text (str, min_length=1, max_length=2000), created_by (str)
- `UpsellCreate(BaseModel)`: upsell_type (str), created_by (Optional[str])
- `SubmissionResponse(BaseModel)`: All table columns properly typed. Include children (Optional[list]) for upsell child submissions.
- `SubmissionListItem(BaseModel)`: id (str), status (str), category (str), client_name (Optional[str]), total_price (float), created_at (str), updated_at (str), upsell_type (Optional[str]), has_children (bool)

**3. Create `backend/app/services/submission_service.py`:**

Service functions using `get_supabase()` (import from `app.services.supabase_client`). Follow the same logging pattern as other services.

Functions:

- `create_submission(data: SubmissionCreate) -> dict`: Insert into submissions, add "created" audit entry. Compute totals from line_items (materials = sum of type=="material" totals, labor = sum of type=="labor" totals). Return created row.

- `get_submission(submission_id: str) -> dict`: Fetch by ID. Query children where parent_submission_id matches. Attach as `children` list. Raise HTTPException(404) if not found.

- `list_submissions(status: Optional[str], limit: int, offset: int) -> dict`: Select with optional status filter, order by created_at DESC, with pagination. Return `{"items": [...], "total": count}`.

- `update_submission(submission_id: str, data: SubmissionUpdate, user: str) -> dict`: Check status == "draft" (raise 400 otherwise). Update provided fields. If line_items provided, recalculate totals. Append "edited" audit entry with old/new diff. Return updated.

- `finalize_submission(submission_id: str, user: str) -> dict`: Validate current status is "draft". Validate line_items is not empty. Set status="pending_approval", finalized_at=now(). Append "finalized" audit entry. Return updated.

- `approve_submission(submission_id: str, user: str) -> dict`: Validate current status is "pending_approval". Set status="approved", approved_at=now(), approved_by=user. Append "approved" audit entry. Return updated.

- `reject_submission(submission_id: str, user: str, reason: Optional[str]) -> dict`: Validate current status is "pending_approval". Set status="rejected". Append "rejected" audit entry with reason. Return updated.

- `return_to_draft_submission(submission_id: str, user: str) -> dict`: Fetch submission, validate current status is "rejected" or "pending_approval" (these are the two statuses that allow transition to "draft" per VALID_TRANSITIONS). Set status="draft", clear finalized_at (set to None). Append "returned_to_draft" audit entry with previous status recorded in changes. Return updated row.

- `add_note(submission_id: str, text: str, user: str) -> dict`: Fetch current notes, append new note (uuid4 id, text, user, ISO timestamp), write back. Also append "note_added" audit entry. Return updated.

- `create_upsell_submission(parent_id: str, upsell_type: str, user: str) -> dict`: Fetch parent (validate exists). Create new submission: parent_submission_id=parent_id, upsell_type, inherit client_name + category from parent, status="draft", empty line_items (estimator fills later), empty pricing_tiers. Append audit entry to parent ("upsell_created"). Return new child.

- `get_upsell_suggestions(category: str) -> list`: Load `upsell_rules.json` from `app/models/` directory. Return category-specific rules + universal rules. Each item has type, name_fr, name_en, description_fr, description_en.

For JSONB operations: Use fetch-append-write pattern (read notes/audit_log array, append in Python, write back). This is acceptable for single-user-per-submission concurrency. The Supabase Python client does not support PostgreSQL `||` operator directly.

All functions: handle `get_supabase()` returning None (raise HTTPException 503 "Database not configured"). Use `logger = logging.getLogger(__name__)`.

**4. Create `backend/app/models/upsell_rules.json`:**

Bilingual JSON config following the pattern from `equipment_config.json`:

```json
{
  "rules": {
    "Bardeaux": [
      {"type": "heating_cables", "name_fr": "Cables chauffants", "name_en": "Heating Cables", "description_fr": "Prevention des barrages de glace en hiver", "description_en": "Ice dam prevention in winter"},
      {"type": "gutters", "name_fr": "Gouttieres", "name_en": "Gutter System", "description_fr": "Installation complete de gouttieres", "description_en": "Complete gutter installation"},
      {"type": "ventilation", "name_fr": "Ventilation", "name_en": "Ventilation Upgrade", "description_fr": "Amelioration de la ventilation du grenier", "description_en": "Attic ventilation improvement"}
    ],
    "Elastomere": [
      {"type": "drain_system", "name_fr": "Systeme de drain", "name_en": "Drain System", "description_fr": "Installation de drains de toit plat", "description_en": "Flat roof drain installation"},
      {"type": "insulation", "name_fr": "Isolation", "name_en": "Insulation", "description_fr": "Isolation thermique du toit", "description_en": "Roof thermal insulation"},
      {"type": "maintenance_contract", "name_fr": "Contrat d'entretien", "name_en": "Maintenance Contract", "description_fr": "Plan d'entretien preventif 2 ans", "description_en": "2-year preventive maintenance plan"}
    ],
    "Metal": [
      {"type": "gutters", "name_fr": "Gouttieres", "name_en": "Gutter System", "description_fr": "Installation complete de gouttieres", "description_en": "Complete gutter installation"},
      {"type": "snow_guards", "name_fr": "Arrets de neige", "name_en": "Snow Guards", "description_fr": "Protection contre les avalanches de neige", "description_en": "Snow avalanche protection"},
      {"type": "warranty_extension", "name_fr": "Extension de garantie", "name_en": "Warranty Extension", "description_fr": "Garantie prolongee sur les materiaux", "description_en": "Extended material warranty"}
    ]
  },
  "universal": [
    {"type": "inspection_plan", "name_fr": "Plan d'inspection annuel", "name_en": "Annual Inspection Plan", "description_fr": "Inspection annuelle professionnelle de la toiture", "description_en": "Annual professional roof inspection"},
    {"type": "maintenance_contract", "name_fr": "Contrat d'entretien", "name_en": "Maintenance Contract", "description_fr": "Plan d'entretien preventif 2 ans", "description_en": "2-year preventive maintenance plan"}
  ]
}
```
  </action>
  <verify>
Run Python import checks:
```bash
cd /Users/aymanbaig/Desktop/Manual\ Library/Toiture-P1/backend && python -c "
from app.schemas.submission import SubmissionStatus, VALID_TRANSITIONS, LineItem, Note, AuditEntry, SubmissionCreate, SubmissionUpdate, SubmissionResponse, SubmissionListItem, NoteCreate, UpsellCreate
print(f'Schemas OK - {len(VALID_TRANSITIONS)} transitions')
assert SubmissionStatus.DRAFT.value == 'draft'
assert len(VALID_TRANSITIONS[SubmissionStatus.APPROVED]) == 0
assert SubmissionStatus.DRAFT in VALID_TRANSITIONS[SubmissionStatus.REJECTED]
assert SubmissionStatus.DRAFT in VALID_TRANSITIONS[SubmissionStatus.PENDING_APPROVAL]
print('Validation OK')
"
cd /Users/aymanbaig/Desktop/Manual\ Library/Toiture-P1/backend && python -c "
from app.services.submission_service import create_submission, get_submission, list_submissions, update_submission, finalize_submission, approve_submission, reject_submission, return_to_draft_submission, add_note, create_upsell_submission, get_upsell_suggestions
print('Service OK - 11 functions')
"
cd /Users/aymanbaig/Desktop/Manual\ Library/Toiture-P1/backend && python -c "
import json
rules = json.load(open('app/models/upsell_rules.json'))
assert 'Bardeaux' in rules['rules']
assert 'Elastomere' in rules['rules']
assert 'Metal' in rules['rules']
assert len(rules['universal']) >= 2
print(f'Upsell rules OK - {sum(len(v) for v in rules[\"rules\"].values())} category rules + {len(rules[\"universal\"])} universal')
"
```
Verify SQL file exists and is valid.
  </verify>
  <done>
4 files created: SQL DDL with submissions table + indexes + trigger, Pydantic schemas (11 models with state machine), submission service (11 functions covering full workflow including return-to-draft), upsell rules JSON with 3 category-specific + 2 universal rules in bilingual format.
  </done>
</task>

<task type="auto">
  <name>Task 2: FastAPI submissions router and main.py registration</name>
  <files>
    backend/app/routers/submissions.py
    backend/app/main.py
  </files>
  <action>
**1. Create `backend/app/routers/submissions.py`:**

Follow the exact pattern from `backend/app/routers/estimate.py`:
- `router = APIRouter(tags=["submissions"])`
- `logger = logging.getLogger(__name__)`
- Import schemas from `app.schemas.submission`
- Import service functions from `app.services.submission_service`
- All endpoints wrapped in try/except with HTTPException

11 endpoints:

```python
@router.post("/submissions", status_code=201)
async def create_submission_endpoint(data: SubmissionCreate):
    """Create a new submission from hybrid quote output."""
    # Call create_submission service
    # Return SubmissionResponse

@router.get("/submissions")
async def list_submissions_endpoint(
    status: Optional[str] = None,
    limit: int = Query(default=50, le=200),
    offset: int = Query(default=0, ge=0),
):
    """List submissions with optional status filter and pagination."""
    # Call list_submissions service
    # Return {"items": [...], "total": int}

@router.get("/submissions/{submission_id}")
async def get_submission_endpoint(submission_id: str):
    """Get single submission with full details including children."""
    # Call get_submission service (raises 404 internally)
    # Return SubmissionResponse

@router.patch("/submissions/{submission_id}")
async def update_submission_endpoint(
    submission_id: str,
    data: SubmissionUpdate,
    x_user_name: str = Header(default="unknown"),
):
    """Update line items, tier, or client name (draft only)."""
    # Call update_submission service (raises 400 if not draft)
    # Return SubmissionResponse

@router.post("/submissions/{submission_id}/finalize")
async def finalize_submission_endpoint(
    submission_id: str,
    x_user_name: str = Header(default="unknown"),
):
    """Finalize submission: draft -> pending_approval."""
    # Call finalize_submission service
    # Return SubmissionResponse

@router.post("/submissions/{submission_id}/approve")
async def approve_submission_endpoint(
    submission_id: str,
    x_user_name: str = Header(default="unknown"),
    x_user_role: str = Header(default="estimator"),
):
    """Approve submission (admin only): pending_approval -> approved."""
    if x_user_role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required for approval")
    # Call approve_submission service
    # Return SubmissionResponse

@router.post("/submissions/{submission_id}/reject")
async def reject_submission_endpoint(
    submission_id: str,
    reason: Optional[str] = Body(default=None),
    x_user_name: str = Header(default="unknown"),
    x_user_role: str = Header(default="estimator"),
):
    """Reject submission (admin only): pending_approval -> rejected."""
    if x_user_role != "admin":
        raise HTTPException(status_code=403, detail="Admin access required for rejection")
    # Call reject_submission service
    # Return SubmissionResponse

@router.post("/submissions/{submission_id}/return-to-draft")
async def return_to_draft_endpoint(
    submission_id: str,
    x_user_name: str = Header(default="unknown"),
):
    """Return submission to draft status: rejected|pending_approval -> draft.

    Allows any user to return a rejected or pending_approval submission
    back to draft for further editing. Clears finalized_at timestamp.
    The state machine VALID_TRANSITIONS validates that only rejected and
    pending_approval statuses can transition to draft.
    """
    # Call return_to_draft_submission service
    # Service validates current status is rejected or pending_approval
    # Return SubmissionResponse

@router.post("/submissions/{submission_id}/notes")
async def add_note_endpoint(
    submission_id: str,
    data: NoteCreate,
):
    """Add timestamped note to submission."""
    # Call add_note service
    # Return SubmissionResponse

@router.post("/submissions/{submission_id}/upsells")
async def create_upsell_endpoint(
    submission_id: str,
    data: UpsellCreate,
    x_user_name: str = Header(default="unknown"),
):
    """Create upsell child submission linked to parent."""
    # Call create_upsell_submission service
    # Return SubmissionResponse (the new child)

@router.get("/submissions/{submission_id}/upsell-suggestions")
async def get_upsell_suggestions_endpoint(submission_id: str):
    """Get category-specific upsell suggestions for this submission."""
    # Fetch submission to get category
    # Call get_upsell_suggestions(category)
    # Return list of suggestion objects
```

Role check pattern: Simple `X-User-Role` header comparison in approve/reject endpoints. The Next.js frontend will set this header from iron-session data. This is consistent with the existing trust model where frontend handles auth (Phase 7 iron-session) and backend trusts same-origin requests.

User identification: `X-User-Name` header for audit trail attribution. Defaults to "unknown" if not provided.

The `return-to-draft` endpoint does NOT require admin role -- any user can return a rejected or pending_approval submission back to draft for editing. This is intentional: estimators need to fix rejected submissions, and pending submissions may need corrections.

**2. Update `backend/app/main.py`:**

Add to the imports on line 9 (after the existing router imports):
```python
from app.routers import customers, dashboard, estimate, feedback, health, materials, quotes, submissions
```

Add router registration after line 64 (after `materials.router`):
```python
app.include_router(submissions.router)
```

This matches the exact pattern of the 7 existing router registrations.
  </action>
  <verify>
Run Python import and route check:
```bash
cd /Users/aymanbaig/Desktop/Manual\ Library/Toiture-P1/backend && python -c "
from app.routers.submissions import router
print(f'Router OK - {len(router.routes)} routes')
for route in router.routes:
    if hasattr(route, 'path') and hasattr(route, 'methods'):
        print(f'  {list(route.methods)} {route.path}')
"
cd /Users/aymanbaig/Desktop/Manual\ Library/Toiture-P1/backend && python -c "
from app.main import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
sub_routes = [r for r in routes if 'submission' in r]
print(f'Registered {len(sub_routes)} submission routes: {sub_routes}')
assert len(sub_routes) >= 11, f'Expected 11+ routes, got {len(sub_routes)}'
print('All routes registered')
"
```
  </verify>
  <done>
Router with 11 endpoints created and registered in main.py. Includes the return-to-draft endpoint (POST /submissions/{id}/return-to-draft) for transitioning rejected or pending_approval submissions back to draft. Approve/reject endpoints require X-User-Role: admin header (403 for non-admin). All mutations include X-User-Name for audit trail. Endpoints follow exact FastAPI patterns from existing routers (APIRouter, tags, logger, try/except, HTTPException).
  </done>
</task>

</tasks>

<verification>
1. All Python imports resolve: schemas, service, router
2. `python -c "from app.main import app"` succeeds with submissions router included
3. VALID_TRANSITIONS state machine: draft->pending_approval (only), approved is terminal, rejected->draft, pending_approval->draft
4. return_to_draft_submission service function validates status is rejected or pending_approval before transitioning
5. POST /submissions/{id}/return-to-draft endpoint exists and calls return_to_draft_submission service
6. Upsell rules JSON loads with Bardeaux/Elastomere/Metal categories + universal
7. SQL DDL contains CREATE TABLE, indexes, trigger, ALTER TABLE estimates
8. Admin role check returns 403 for non-admin on approve/reject (but NOT on return-to-draft)
</verification>

<success_criteria>
1. SQL DDL creates submissions table with all columns, constraints, indexes, trigger
2. 11 Pydantic models cover all CRUD, workflow, and upsell operations
3. 11 service functions handle full lifecycle: create -> edit -> finalize -> approve/reject -> return-to-draft + notes + upsells
4. 11 FastAPI endpoints registered and reachable at /submissions/*
5. State machine prevents invalid transitions (400 errors)
6. Role-based access blocks non-admin approval/rejection (403 errors)
7. Return-to-draft endpoint accessible to any authenticated user
8. Audit trail entries appended on every mutation
9. Upsell rules JSON has 3 categories + 2 universal suggestions, bilingual
</success_criteria>

<output>
After completion, create `.planning/phases/23-submission-workflow-editing/23-01-SUMMARY.md`
</output>
