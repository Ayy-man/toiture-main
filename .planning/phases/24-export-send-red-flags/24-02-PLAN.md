---
phase: 24-export-send-red-flags
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/red_flag_evaluator.py
  - backend/app/schemas/red_flag.py
  - backend/app/services/email_service.py
  - backend/app/routers/submissions.py
  - backend/sql/alter_submissions_send_columns.sql
autonomous: true
user_setup:
  - service: resend
    why: "Email delivery for sending quotes to clients"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
    dashboard_config:
      - task: "Create Resend account and verify domain (toiturelv.com or use onboarding@resend.dev for testing)"
        location: "https://resend.com/signup"

must_haves:
  truths:
    - "Red flag evaluator checks 5 categories: budget_mismatch, geographic, material_risk, crew_availability, low_margin"
    - "GET /submissions/{id}/red-flags returns list of applicable red flags with category, severity, message, and dismissible flag"
    - "Red flags with severity 'critical' for low_margin and material_risk, 'warning' for others"
    - "Email service can send quote with PDF+DOCX attachments via Resend API"
    - "POST /submissions/{id}/send accepts sendOption (now/schedule/draft), recipientEmail, and optional scheduledDate"
    - "Send now: immediately calls Resend API and updates send_status to 'sent'"
    - "Save as draft: updates send_status to 'draft' (no email sent)"
    - "Schedule: stores scheduled_send_at timestamp and updates send_status to 'scheduled'"
    - "SQL migration adds send_status, scheduled_send_at, sent_at, recipient_email columns to submissions table"
    - "POST /submissions/{id}/dismiss-flags logs dismissed flags in audit_log JSONB"
  artifacts:
    - path: "backend/app/services/red_flag_evaluator.py"
      provides: "Rule-based red flag evaluation service with 5 risk categories"
      exports: ["RedFlag", "evaluate_red_flags"]
    - path: "backend/app/schemas/red_flag.py"
      provides: "Pydantic models for red flag request/response"
      exports: ["RedFlagResponse", "SendSubmissionRequest", "SendStatus"]
    - path: "backend/app/services/email_service.py"
      provides: "Resend email integration for sending quotes with attachments"
      exports: ["send_quote_email"]
    - path: "backend/app/routers/submissions.py"
      provides: "Extended submissions router with red-flags, send, and dismiss-flags endpoints"
      contains: "red-flags"
    - path: "backend/sql/alter_submissions_send_columns.sql"
      provides: "SQL migration adding send_status and related columns to submissions table"
      contains: "send_status"
  key_links:
    - from: "backend/app/routers/submissions.py"
      to: "backend/app/services/red_flag_evaluator.py"
      via: "evaluate_red_flags() call in GET /submissions/{id}/red-flags"
      pattern: "evaluate_red_flags"
    - from: "backend/app/routers/submissions.py"
      to: "backend/app/services/email_service.py"
      via: "send_quote_email() call in POST /submissions/{id}/send"
      pattern: "send_quote_email"
    - from: "backend/app/services/email_service.py"
      to: "Resend API"
      via: "resend.Emails.send()"
      pattern: "resend"
---

<objective>
Build the backend infrastructure for red flag evaluation, email delivery, and send workflow. This includes: a rule-based red flag evaluator service, Pydantic schemas for red flags and send requests, Resend email service for quote delivery, SQL migration for send tracking columns, and new endpoints on the submissions router.

Purpose: Backend APIs that the frontend send dialog (Plan 24-03) will consume. Red flags warn estimators about risky submissions. Email service delivers quotes to clients with PDF+DOCX attachments.

Output: 2 new services, 1 new schema file, 1 SQL migration, extended submissions router with 3 new endpoints (red-flags, send, dismiss-flags).
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-export-send-red-flags/24-RESEARCH.md
@.planning/phases/23-submission-workflow-editing/23-01-PLAN.md
@backend/app/schemas/hybrid_quote.py
@backend/app/services/supabase_client.py
@backend/app/routers/submissions.py
@backend/app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Red flag evaluator service, Pydantic schemas, and SQL migration</name>
  <files>
    backend/app/services/red_flag_evaluator.py
    backend/app/schemas/red_flag.py
    backend/sql/alter_submissions_send_columns.sql
  </files>
  <action>
**1. Create `backend/app/schemas/red_flag.py`:**

Follow the exact Pydantic pattern from `backend/app/schemas/hybrid_quote.py` (BaseModel, Field, Literal, Enum).

Models:

```python
from enum import Enum
from typing import Optional, List
from pydantic import BaseModel, Field
from datetime import datetime

class RedFlagSeverity(str, Enum):
    warning = "warning"
    critical = "critical"

class RedFlagCategory(str, Enum):
    budget_mismatch = "budget_mismatch"
    geographic = "geographic"
    material_risk = "material_risk"
    crew_availability = "crew_availability"
    low_margin = "low_margin"

class RedFlagResponse(BaseModel):
    category: RedFlagCategory
    severity: RedFlagSeverity
    message_fr: str
    message_en: str
    dismissible: bool = True

class SendStatus(str, Enum):
    draft = "draft"
    scheduled = "scheduled"
    sent = "sent"
    failed = "failed"

class SendSubmissionRequest(BaseModel):
    send_option: str = Field(..., pattern="^(now|schedule|draft)$")
    recipient_email: Optional[str] = Field(None, pattern=r"^[^@]+@[^@]+\.[^@]+$")
    email_subject: Optional[str] = None
    email_body: Optional[str] = None
    scheduled_send_at: Optional[datetime] = None

    # Validation: if send_option is "now" or "schedule", recipient_email is required
    # if send_option is "schedule", scheduled_send_at is required
    # Use model_validator(mode="after") for cross-field validation

class DismissFlagsRequest(BaseModel):
    dismissed_categories: List[RedFlagCategory]
    dismissed_by: str = "estimator"
```

**2. Create `backend/app/services/red_flag_evaluator.py`:**

```python
from typing import List, Dict, Any, Optional
from datetime import datetime
from app.schemas.red_flag import RedFlagResponse, RedFlagSeverity, RedFlagCategory

def evaluate_red_flags(
    submission: Dict[str, Any],
    request_data: Optional[Dict[str, Any]] = None
) -> List[RedFlagResponse]:
    """Evaluate submission data for red flag warnings. Returns list of applicable flags."""
    flags = []

    # Parse request_data from submission if not provided separately
    # Phase 23 stores original request fields in the submission record
    if request_data is None:
        request_data = {}

    # 1. Budget mismatch: client quoted_total is 30%+ below predicted total
    quoted_total = request_data.get("quoted_total")
    predicted_total = submission.get("total_price", 0)
    if quoted_total and predicted_total > 0:
        if float(quoted_total) < float(predicted_total) * 0.7:
            flags.append(RedFlagResponse(
                category=RedFlagCategory.budget_mismatch,
                severity=RedFlagSeverity.warning,
                message_fr=f"Le budget client ({quoted_total:,.0f}$) est 30%+ inferieur au prix prevu ({predicted_total:,.0f}$)",
                message_en=f"Client budget (${quoted_total:,.0f}) is 30%+ below predicted (${predicted_total:,.0f})",
            ))

    # 2. Geographic distance: red_flag zone means >60km from LV HQ
    geographic_zone = request_data.get("geographic_zone")
    if geographic_zone == "red_flag":
        flags.append(RedFlagResponse(
            category=RedFlagCategory.geographic,
            severity=RedFlagSeverity.warning,
            message_fr="Le chantier est a plus de 60km du siege de Toiture LV",
            message_en="Site is more than 60km from Toiture LV headquarters",
        ))

    # 3. Material risk: imported materials with 6+ week lead time
    supply_chain_risk = request_data.get("supply_chain_risk")
    if supply_chain_risk == "import":
        flags.append(RedFlagResponse(
            category=RedFlagCategory.material_risk,
            severity=RedFlagSeverity.critical,
            message_fr="Materiaux importes avec delai de 6+ semaines",
            message_en="Imported materials with 6+ week lead time",
        ))

    # 4. Crew availability: multi-day during peak season (June-Sept)
    duration_type = request_data.get("duration_type")
    if duration_type == "multi_day":
        now = datetime.now()
        if 6 <= now.month <= 9:
            flags.append(RedFlagResponse(
                category=RedFlagCategory.crew_availability,
                severity=RedFlagSeverity.warning,
                message_fr="Projet multi-jours en haute saison (juin-septembre)",
                message_en="Multi-day project during peak season (June-September)",
            ))

    # 5. Low margin: margin < 15%
    materials_cost = float(submission.get("total_materials_cost", 0))
    labor_cost = float(submission.get("total_labor_cost", 0))
    total_price = float(submission.get("total_price", 0))
    total_costs = materials_cost + labor_cost
    margin = (total_price - total_costs) / total_price if total_price > 0 else 0

    if margin < 0.15:
        margin_pct = margin * 100
        flags.append(RedFlagResponse(
            category=RedFlagCategory.low_margin,
            severity=RedFlagSeverity.critical,
            message_fr=f"La marge est de {margin_pct:.1f}% (seuil: 15%)",
            message_en=f"Margin is {margin_pct:.1f}% (threshold: 15%)",
        ))

    return flags
```

**3. Create `backend/sql/alter_submissions_send_columns.sql`:**

SQL migration to add send-tracking columns to submissions table (run in Supabase SQL editor after Phase 23's table creation):

```sql
-- Phase 24: Add send tracking columns to submissions table
ALTER TABLE submissions ADD COLUMN IF NOT EXISTS send_status text DEFAULT 'draft';
ALTER TABLE submissions ADD COLUMN IF NOT EXISTS scheduled_send_at timestamptz;
ALTER TABLE submissions ADD COLUMN IF NOT EXISTS sent_at timestamptz;
ALTER TABLE submissions ADD COLUMN IF NOT EXISTS recipient_email text;
ALTER TABLE submissions ADD COLUMN IF NOT EXISTS email_subject text;
ALTER TABLE submissions ADD COLUMN IF NOT EXISTS email_body text;

-- Add constraint for valid send statuses
-- Use DO block to avoid error if constraint already exists
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'valid_send_status'
  ) THEN
    ALTER TABLE submissions ADD CONSTRAINT valid_send_status
      CHECK (send_status IN ('draft', 'scheduled', 'sent', 'failed'));
  END IF;
END $$;

-- Index for querying scheduled submissions
CREATE INDEX IF NOT EXISTS idx_submissions_send_status ON submissions(send_status);
CREATE INDEX IF NOT EXISTS idx_submissions_scheduled_send ON submissions(scheduled_send_at)
  WHERE send_status = 'scheduled';
```
  </action>
  <verify>
Run `cd backend && python -c "from app.schemas.red_flag import RedFlagResponse, SendSubmissionRequest, SendStatus, DismissFlagsRequest; print('schemas OK')"` and `cd backend && python -c "from app.services.red_flag_evaluator import evaluate_red_flags; print('evaluator OK')"`. Verify SQL file exists with ALTER TABLE statements.
  </verify>
  <done>
Red flag evaluator evaluates 5 categories returning bilingual messages. Pydantic schemas validate send requests with cross-field validation. SQL migration ready for Supabase SQL editor.
  </done>
</task>

<task type="auto">
  <name>Task 2: Email service and submissions router send/red-flag endpoints</name>
  <files>
    backend/app/services/email_service.py
    backend/app/routers/submissions.py
  </files>
  <action>
**1. Create `backend/app/services/email_service.py`:**

Email service using Resend Python SDK for sending quotes with attachments.

```python
import os
import logging
from typing import Optional

logger = logging.getLogger(__name__)

_resend_client = None

def get_resend_client():
    """Lazy-init Resend client. Returns None if API key not configured."""
    global _resend_client
    api_key = os.getenv("RESEND_API_KEY")
    if not api_key:
        return None
    if _resend_client is None:
        import resend
        resend.api_key = api_key
        _resend_client = resend
    return _resend_client

async def send_quote_email(
    to_email: str,
    subject: str,
    body: str,
    pdf_bytes: Optional[bytes] = None,
    docx_bytes: Optional[bytes] = None,
    from_email: str = "soumissions@toiturelv.com",
    filename_prefix: str = "Soumission"
) -> dict:
    """
    Send quote email with optional PDF and DOCX attachments.

    Returns dict with 'id' on success.
    Raises RuntimeError if Resend not configured or send fails.
    """
    client = get_resend_client()
    if client is None:
        raise RuntimeError("RESEND_API_KEY not configured")

    attachments = []
    if pdf_bytes:
        import base64
        attachments.append({
            "filename": f"{filename_prefix}.pdf",
            "content": list(pdf_bytes),  # Resend Python SDK accepts list of ints
        })
    if docx_bytes:
        attachments.append({
            "filename": f"{filename_prefix}.docx",
            "content": list(docx_bytes),
        })

    params = {
        "from": from_email,
        "to": [to_email],
        "subject": subject,
        "html": body,
    }
    if attachments:
        params["attachments"] = attachments

    try:
        result = client.Emails.send(params)
        logger.info(f"Email sent to {to_email}, id={result.get('id', 'unknown')}")
        return result
    except Exception as e:
        logger.error(f"Email send failed: {e}")
        raise RuntimeError(f"Email send failed: {str(e)}")
```

Note: `pip install resend` should be added to `backend/requirements.txt` if not already there. Check and add if missing.

Also check: `cd backend && pip install resend` or `pip install resend` to ensure it's available.

**2. Extend `backend/app/routers/submissions.py`:**

**IMPORTANT:** Phase 23-01 creates this file with CRUD + workflow endpoints. This plan ADDS 3 new endpoints to the same router. Read the file first (Phase 23 must be executed first — if the file doesn't exist yet, create it as a new file with just these endpoints and a router = APIRouter(prefix="/submissions", tags=["submissions"])).

**If the file exists (Phase 23 already executed):** Add these imports and endpoints at the end of the file.

**If the file doesn't exist yet:** Create it with a router prefix and just these 3 endpoints. Phase 23 will merge when it runs.

Add imports:
```python
from app.services.red_flag_evaluator import evaluate_red_flags
from app.services.email_service import send_quote_email
from app.schemas.red_flag import RedFlagResponse, SendSubmissionRequest, DismissFlagsRequest, SendStatus
```

**Endpoint 1: GET /submissions/{id}/red-flags**
```python
@router.get("/submissions/{submission_id}/red-flags", response_model=List[RedFlagResponse])
async def get_red_flags(submission_id: str):
    """Evaluate red flags for a submission before sending."""
    supabase = get_supabase()
    if not supabase:
        raise HTTPException(503, "Database not available")

    result = supabase.table("submissions").select("*").eq("id", submission_id).single().execute()
    if not result.data:
        raise HTTPException(404, "Submission not found")

    submission = result.data
    # Extract request data fields that red flags check
    # Phase 22 fields are stored in the submission record
    request_data = {
        "quoted_total": submission.get("quoted_total"),
        "geographic_zone": submission.get("geographic_zone"),
        "supply_chain_risk": submission.get("supply_chain_risk"),
        "duration_type": submission.get("duration_type"),
    }

    flags = evaluate_red_flags(submission, request_data)
    return flags
```

**Endpoint 2: POST /submissions/{id}/send**
```python
@router.post("/submissions/{submission_id}/send")
async def send_submission(submission_id: str, request: SendSubmissionRequest):
    """Send, schedule, or save submission as draft."""
    supabase = get_supabase()
    if not supabase:
        raise HTTPException(503, "Database not available")

    result = supabase.table("submissions").select("*").eq("id", submission_id).single().execute()
    if not result.data:
        raise HTTPException(404, "Submission not found")

    submission = result.data

    # Only approved submissions can be sent
    if submission.get("status") != "approved":
        raise HTTPException(400, "Only approved submissions can be sent")

    update_data = {
        "recipient_email": request.recipient_email,
        "email_subject": request.email_subject,
        "email_body": request.email_body,
    }

    if request.send_option == "draft":
        update_data["send_status"] = "draft"

    elif request.send_option == "now":
        if not request.recipient_email:
            raise HTTPException(400, "recipient_email required for send now")

        # Send email via Resend
        subject = request.email_subject or f"Soumission - Toiture LV - {submission.get('category', '')}"
        body = request.email_body or f"<p>Veuillez trouver ci-joint votre soumission.</p><p>Toiture LV</p>"

        try:
            # Note: PDF/DOCX generation happens on frontend — for now, send without attachments
            # Frontend will generate and pass as base64 in a future iteration,
            # or we generate server-side. For MVP, send email body only.
            await send_quote_email(
                to_email=request.recipient_email,
                subject=subject,
                body=body,
            )
            update_data["send_status"] = "sent"
            update_data["sent_at"] = "now()"  # Will need to use Python datetime
        except RuntimeError as e:
            update_data["send_status"] = "failed"
            # Log error in audit_log
            import json
            from datetime import datetime
            audit_entry = {
                "action": "send_failed",
                "timestamp": datetime.utcnow().isoformat(),
                "error": str(e)
            }
            existing_audit = submission.get("audit_log", []) or []
            existing_audit.append(audit_entry)
            update_data["audit_log"] = existing_audit

    elif request.send_option == "schedule":
        if not request.recipient_email:
            raise HTTPException(400, "recipient_email required for scheduled send")
        if not request.scheduled_send_at:
            raise HTTPException(400, "scheduled_send_at required for scheduled send")

        update_data["send_status"] = "scheduled"
        update_data["scheduled_send_at"] = request.scheduled_send_at.isoformat()
        # Note: Actual scheduled delivery via QStash is out of scope for MVP
        # Scheduled submissions can be picked up by a future cron job

    supabase.table("submissions").update(update_data).eq("id", submission_id).execute()

    return {"status": "ok", "send_status": update_data.get("send_status", "draft")}
```

**Endpoint 3: POST /submissions/{id}/dismiss-flags**
```python
@router.post("/submissions/{submission_id}/dismiss-flags")
async def dismiss_red_flags(submission_id: str, request: DismissFlagsRequest):
    """Log dismissed red flags in audit trail."""
    supabase = get_supabase()
    if not supabase:
        raise HTTPException(503, "Database not available")

    result = supabase.table("submissions").select("audit_log").eq("id", submission_id).single().execute()
    if not result.data:
        raise HTTPException(404, "Submission not found")

    from datetime import datetime
    audit_entry = {
        "action": "red_flags_dismissed",
        "timestamp": datetime.utcnow().isoformat(),
        "dismissed_by": request.dismissed_by,
        "categories": [c.value for c in request.dismissed_categories],
    }

    existing_audit = result.data.get("audit_log", []) or []
    existing_audit.append(audit_entry)

    supabase.table("submissions").update({"audit_log": existing_audit}).eq("id", submission_id).execute()

    return {"status": "ok", "dismissed": len(request.dismissed_categories)}
```

**Also:** Add `resend` to `backend/requirements.txt` if it exists, or to the appropriate dependency file. Check what dependency management the backend uses (requirements.txt or pyproject.toml) and add `resend>=3.0.0`.
  </action>
  <verify>
Run `cd backend && python -c "from app.services.email_service import send_quote_email; print('email service OK')"`. Run `cd backend && python -c "from app.services.red_flag_evaluator import evaluate_red_flags; print('evaluator OK')"`. Check submissions router has the 3 new endpoints by grepping for "red-flags", "/send", "dismiss-flags".
  </verify>
  <done>
Three new endpoints on submissions router: GET /submissions/{id}/red-flags, POST /submissions/{id}/send, POST /submissions/{id}/dismiss-flags. Email service uses Resend with graceful error handling. SQL migration ready. All endpoints return proper error codes (400, 404, 503).
  </done>
</task>

</tasks>

<verification>
1. `cd backend && python -c "from app.schemas.red_flag import RedFlagResponse, SendSubmissionRequest; print('OK')"` — schemas import
2. `cd backend && python -c "from app.services.red_flag_evaluator import evaluate_red_flags; print('OK')"` — evaluator imports
3. `cd backend && python -c "from app.services.email_service import send_quote_email; print('OK')"` — email service imports
4. Grep submissions router for "red-flags", "send", "dismiss-flags" endpoints
5. SQL migration file exists at `backend/sql/alter_submissions_send_columns.sql`
6. `resend` package in backend dependencies
</verification>

<success_criteria>
- Red flag evaluator checks all 5 categories with bilingual messages
- Email service wraps Resend SDK with lazy init and graceful error handling
- Three new API endpoints for red flags, sending, and flag dismissal
- SQL migration extends submissions table with send tracking columns
- All new code follows existing backend patterns (Pydantic schemas, service layer, router)
</success_criteria>

<output>
After completion, create `.planning/phases/24-export-send-red-flags/24-02-SUMMARY.md`
</output>
