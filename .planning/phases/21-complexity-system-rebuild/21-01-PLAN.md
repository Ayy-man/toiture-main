---
phase: 21-complexity-system-rebuild
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/complexity_tiers_config.json
  - backend/app/services/complexity_calculator.py
  - backend/app/schemas/hybrid_quote.py
autonomous: true

must_haves:
  truths:
    - "Backend accepts new tier-based complexity fields (complexity_tier 1-6, complexity_score 0-100) alongside old fields"
    - "Complexity calculator returns base_hours + tier_hours + factor_hours breakdown from config"
    - "Old complexity_aggregate field remains optional for backward compatibility"
    - "Config file drives all business logic values without code changes"
  artifacts:
    - path: "backend/app/models/complexity_tiers_config.json"
      provides: "Tier definitions, factor hour values, base time per category"
      contains: "tiers"
    - path: "backend/app/services/complexity_calculator.py"
      provides: "calculate_complexity_hours() function"
      exports: ["calculate_complexity_hours"]
    - path: "backend/app/schemas/hybrid_quote.py"
      provides: "Updated HybridQuoteRequest with tier + factor fields"
      contains: "complexity_tier"
  key_links:
    - from: "backend/app/services/complexity_calculator.py"
      to: "backend/app/models/complexity_tiers_config.json"
      via: "json.load at module level"
      pattern: "load.*complexity_tiers_config"
    - from: "backend/app/schemas/hybrid_quote.py"
      to: "complexity_tier"
      via: "Optional field with ge=1 le=6"
      pattern: "complexity_tier.*Optional"
---

<objective>
Create the backend foundation for the tier-based complexity system: config-driven business rules JSON, complexity hour calculator service, and updated Pydantic schema with new fields alongside backward-compatible old fields.

Purpose: Backend must accept both old (0-56 slider) and new (tier 1-6 with factor checklist) complexity inputs, with a calculator that converts tiers + factors into additive labor hours using configurable business rules.

Output: complexity_tiers_config.json, complexity_calculator.py, updated hybrid_quote.py schema
</objective>

<execution_context>
@/Users/aymanbaig/.claude/get-shit-done/workflows/execute-plan.md
@/Users/aymanbaig/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@backend/app/schemas/hybrid_quote.py
@backend/app/services/hybrid_quote.py
@.planning/phases/21-complexity-system-rebuild/21-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create complexity tiers config JSON and calculator service</name>
  <files>
    backend/app/models/complexity_tiers_config.json
    backend/app/services/complexity_calculator.py
  </files>
  <action>
Create `backend/app/models/complexity_tiers_config.json` with this structure:

```json
{
  "version": "1.0",
  "tiers": [
    {
      "tier": 1,
      "name_fr": "Simple / Standard",
      "name_en": "Simple / Standard",
      "score_min": 0,
      "score_max": 16,
      "description_fr": "Maison plain-pied, toit plat a faible pente (0-4/12), acces facile par entree, pas de grue, 1-2 sections, materiaux standards",
      "description_en": "Single-story house, flat to low pitch (0-4/12), easy driveway access, no crane, 1-2 sections, standard materials",
      "base_hours_added": 0
    },
    {
      "tier": 2,
      "name_fr": "Modere",
      "name_en": "Moderate",
      "score_min": 17,
      "score_max": 33,
      "description_fr": "Maison 2 etages, pente 4/12 a 6/12, bon acces rue, quelques penetrations, 2-3 sections, arrachage standard",
      "description_en": "Two-story house, 4/12 to 6/12 pitch, good street access, some penetrations, 2-3 sections, standard tear-off",
      "base_hours_added": 4
    },
    {
      "tier": 3,
      "name_fr": "Complexe",
      "name_en": "Complex",
      "score_min": 34,
      "score_max": 50,
      "description_fr": "2 etages avec forte pente (6/12-8/12), acces limite, penetrations multiples, 3-4 sections, arrachage multi-couches",
      "description_en": "Two-story with steep pitch (6/12-8/12), limited access, multiple penetrations, 3-4 sections, multi-layer tear-off",
      "base_hours_added": 8
    },
    {
      "tier": 4,
      "name_fr": "Haute complexite",
      "name_en": "High Complexity",
      "score_min": 51,
      "score_max": 66,
      "description_fr": "3 etages ou pente 8/12+, acces difficile (grue recommandee), penetrations nombreuses, 4+ sections, equipement securite requis",
      "description_en": "Three-story or 8/12+ pitch, difficult access (crane recommended), many penetrations, 4+ sections, safety equipment required",
      "base_hours_added": 16
    },
    {
      "tier": 5,
      "name_fr": "Tres haute complexite",
      "name_en": "Very High Complexity",
      "score_min": 67,
      "score_max": 83,
      "description_fr": "3 etages, pente 10/12+, grue requise, acces extreme (centre-ville), penetrations etendues, 5+ sections, couches multiples",
      "description_en": "Three-story, 10/12+ pitch, crane required, extreme access (downtown), extensive penetrations, 5+ sections, multiple layers",
      "base_hours_added": 24
    },
    {
      "tier": 6,
      "name_fr": "Extreme",
      "name_en": "Extreme",
      "score_min": 84,
      "score_max": 100,
      "description_fr": "Commercial/haute elevation, pente extreme, grue obligatoire, acces dangereux (echafaudage + harnais), travaux structuraux, conditions hivernales",
      "description_en": "Commercial/high-rise, extreme pitch, crane mandatory, hazardous access (scaffolding + harness), structural work, winter conditions",
      "base_hours_added": 40
    }
  ],
  "factors": {
    "roof_pitch": {
      "type": "dropdown",
      "options": {
        "flat": {"hours": 0, "label_fr": "Plat (0-2/12)", "label_en": "Flat (0-2/12)"},
        "low": {"hours": 1, "label_fr": "Faible (3/12-4/12)", "label_en": "Low (3/12-4/12)"},
        "medium": {"hours": 2, "label_fr": "Moyen (5/12-6/12)", "label_en": "Medium (5/12-6/12)"},
        "steep": {"hours": 4, "label_fr": "Forte (7/12-8/12)", "label_en": "Steep (7/12-8/12)"},
        "very_steep": {"hours": 8, "label_fr": "Tres forte (9/12+)", "label_en": "Very Steep (9/12+)"}
      }
    },
    "access_difficulty": {
      "type": "checklist",
      "options": {
        "no_crane": {"hours": 6, "label_fr": "Pas d'acces pour grue", "label_en": "No crane access"},
        "narrow_driveway": {"hours": 2, "label_fr": "Entree etroite", "label_en": "Narrow driveway"},
        "street_blocking": {"hours": 3, "label_fr": "Blocage de rue requis", "label_en": "Street blocking required"},
        "high_elevation": {"hours": 4, "label_fr": "Haute elevation (3+ etages)", "label_en": "High elevation (3+ stories)"},
        "difficult_terrain": {"hours": 2, "label_fr": "Terrain difficile", "label_en": "Difficult terrain"},
        "no_material_drop": {"hours": 3, "label_fr": "Pas de zone de depot", "label_en": "No material drop zone"}
      }
    },
    "demolition": {
      "type": "dropdown",
      "options": {
        "none": {"hours": 0, "label_fr": "Aucun", "label_en": "None"},
        "single_layer": {"hours": 2, "label_fr": "Une couche", "label_en": "Single layer"},
        "multi_layer": {"hours": 6, "label_fr": "Multi-couches", "label_en": "Multi-layer"},
        "structural": {"hours": 10, "label_fr": "Structural", "label_en": "Structural"}
      }
    },
    "penetrations": {
      "type": "number",
      "hours_per_item": 0.5,
      "label_fr": "Nombre de penetrations (events, tuyaux, puits de lumiere)",
      "label_en": "Number of penetrations (vents, pipes, skylights)"
    },
    "security": {
      "type": "checklist",
      "options": {
        "harness": {"hours": 1, "label_fr": "Harnais de securite", "label_en": "Safety harness"},
        "scaffolding": {"hours": 4, "label_fr": "Echafaudage", "label_en": "Scaffolding"},
        "guardrails": {"hours": 2, "label_fr": "Garde-corps", "label_en": "Guardrails"},
        "winter_safety": {"hours": 3, "label_fr": "Securite hivernale", "label_en": "Winter safety"}
      }
    },
    "material_removal": {
      "type": "dropdown",
      "options": {
        "none": {"hours": 0, "label_fr": "Aucun", "label_en": "None"},
        "standard": {"hours": 2, "label_fr": "Standard", "label_en": "Standard"},
        "heavy": {"hours": 4, "label_fr": "Lourd", "label_en": "Heavy"},
        "hazardous": {"hours": 6, "label_fr": "Dangereux (amiante)", "label_en": "Hazardous (asbestos)"}
      }
    },
    "roof_sections": {
      "type": "number",
      "hours_per_item_above": 1,
      "baseline": 2,
      "label_fr": "Nombre de sections de toit",
      "label_en": "Number of roof sections"
    },
    "previous_layers": {
      "type": "number",
      "hours_per_item_above": 2,
      "baseline": 1,
      "label_fr": "Nombre de couches precedentes",
      "label_en": "Number of previous layers"
    }
  },
  "base_time_per_category": {
    "Bardeaux": {"hours_per_1000sqft": 16, "min_hours": 8},
    "Elastomere": {"hours_per_1000sqft": 20, "min_hours": 12},
    "Metal": {"hours_per_1000sqft": 24, "min_hours": 10},
    "TPO": {"hours_per_1000sqft": 18, "min_hours": 10},
    "EPDM": {"hours_per_1000sqft": 18, "min_hours": 10},
    "Autres": {"hours_per_1000sqft": 20, "min_hours": 10}
  },
  "_note": "PLACEHOLDER VALUES - Laurent must validate base_time, tier hours, and factor hours before production use"
}
```

Create `backend/app/services/complexity_calculator.py`:

```python
"""Complexity calculator service for tier-based labor hour estimation.

Converts tier selection + factor checklist into additive labor hours
using config-driven business rules from complexity_tiers_config.json.

Formula: total_labor_hours = base_hours + tier_hours + factor_hours
"""

import json
import logging
from pathlib import Path
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)

# Load config at module level (same pattern as predictor.py)
_CONFIG_PATH = Path(__file__).parent.parent / "models" / "complexity_tiers_config.json"
_config: Optional[Dict] = None


def _load_config() -> Dict:
    """Load and cache tier config from JSON file."""
    global _config
    if _config is None:
        with open(_CONFIG_PATH) as f:
            _config = json.load(f)
        logger.info(f"Loaded complexity tiers config v{_config.get('version', '?')}")
    return _config


def get_tier_config() -> Dict:
    """Get the full tier configuration (for frontend to consume via API if needed)."""
    return _load_config()


def calculate_complexity_hours(
    category: str,
    sqft: float,
    tier: int,
    factors: Dict[str, Any],
) -> Dict[str, Any]:
    """Calculate total labor hours from tier + factors.

    Args:
        category: Job category (e.g., "Bardeaux")
        sqft: Square footage of roof area
        tier: Complexity tier (1-6)
        factors: Dict of factor values:
            - roof_pitch: str (flat|low|medium|steep|very_steep)
            - access_difficulty: List[str] (checklist items)
            - demolition: str (none|single_layer|multi_layer|structural)
            - penetrations_count: int
            - security: List[str] (checklist items)
            - material_removal: str (none|standard|heavy|hazardous)
            - roof_sections_count: int
            - previous_layers_count: int

    Returns:
        Dict with base_hours, tier_hours, factor_hours, total_hours, breakdown, tier_name
    """
    config = _load_config()

    # 1. Base time (sqft-scaled by category)
    cat_key = category if category in config["base_time_per_category"] else "Autres"
    base_config = config["base_time_per_category"][cat_key]
    base_hours = (sqft / 1000) * base_config["hours_per_1000sqft"]
    base_hours = max(base_hours, base_config["min_hours"])

    # 2. Tier hours
    if tier < 1 or tier > len(config["tiers"]):
        tier = 1  # Default to simple if invalid
    tier_config = config["tiers"][tier - 1]
    tier_hours = tier_config["base_hours_added"]
    tier_name = tier_config["name_fr"]

    # 3. Factor hours (additive)
    factor_hours = 0.0
    breakdown = {}

    # Roof pitch (dropdown)
    pitch = factors.get("roof_pitch")
    if pitch and pitch in config["factors"]["roof_pitch"]["options"]:
        h = config["factors"]["roof_pitch"]["options"][pitch]["hours"]
        factor_hours += h
        breakdown["roof_pitch"] = h

    # Access difficulty (checklist - sum all selected)
    for item in factors.get("access_difficulty", []):
        if item in config["factors"]["access_difficulty"]["options"]:
            h = config["factors"]["access_difficulty"]["options"][item]["hours"]
            factor_hours += h
            breakdown[f"access_{item}"] = h

    # Demolition (dropdown)
    demo = factors.get("demolition")
    if demo and demo in config["factors"]["demolition"]["options"]:
        h = config["factors"]["demolition"]["options"][demo]["hours"]
        factor_hours += h
        breakdown["demolition"] = h

    # Penetrations (count-based)
    pen_count = factors.get("penetrations_count", 0)
    if pen_count > 0:
        h = pen_count * config["factors"]["penetrations"]["hours_per_item"]
        factor_hours += h
        breakdown["penetrations"] = h

    # Security (checklist - sum all selected)
    for item in factors.get("security", []):
        if item in config["factors"]["security"]["options"]:
            h = config["factors"]["security"]["options"][item]["hours"]
            factor_hours += h
            breakdown[f"security_{item}"] = h

    # Material removal (dropdown)
    removal = factors.get("material_removal")
    if removal and removal in config["factors"]["material_removal"]["options"]:
        h = config["factors"]["material_removal"]["options"][removal]["hours"]
        factor_hours += h
        breakdown["material_removal"] = h

    # Roof sections (count above baseline)
    sections = factors.get("roof_sections_count", 0)
    sections_config = config["factors"]["roof_sections"]
    if sections > sections_config["baseline"]:
        h = (sections - sections_config["baseline"]) * sections_config["hours_per_item_above"]
        factor_hours += h
        breakdown["roof_sections"] = h

    # Previous layers (count above baseline)
    layers = factors.get("previous_layers_count", 0)
    layers_config = config["factors"]["previous_layers"]
    if layers > layers_config["baseline"]:
        h = (layers - layers_config["baseline"]) * layers_config["hours_per_item_above"]
        factor_hours += h
        breakdown["previous_layers"] = h

    total_hours = base_hours + tier_hours + factor_hours

    # Compute complexity_score (0-100) from tier
    complexity_score = tier_config["score_min"] + (
        (tier_config["score_max"] - tier_config["score_min"]) // 2
    )

    return {
        "base_hours": round(base_hours, 1),
        "tier_hours": round(tier_hours, 1),
        "factor_hours": round(factor_hours, 1),
        "total_hours": round(total_hours, 1),
        "breakdown": breakdown,
        "tier_name": tier_name,
        "complexity_score": complexity_score,
    }
```

Use the module-level dict pattern consistent with `predictor.py` and `llm_reasoning.py`. The `_load_config()` function caches the JSON so it's only read once.

NOTE: All hour values are PLACEHOLDERS marked in the config `_note` field. Laurent must validate before production. The system works correctly with any values in the config -- that's the point of config-driven design.
  </action>
  <verify>
Run from backend directory:
```bash
cd backend && python -c "
from app.services.complexity_calculator import calculate_complexity_hours, get_tier_config
config = get_tier_config()
assert len(config['tiers']) == 6
assert 'Bardeaux' in config['base_time_per_category']

result = calculate_complexity_hours(
    category='Bardeaux',
    sqft=1500,
    tier=3,
    factors={
        'roof_pitch': 'steep',
        'access_difficulty': ['no_crane', 'narrow_driveway'],
        'demolition': 'multi_layer',
        'penetrations_count': 4,
        'security': ['harness'],
        'material_removal': 'standard',
        'roof_sections_count': 4,
        'previous_layers_count': 2,
    }
)
print(f'Result: {result}')
assert result['base_hours'] > 0
assert result['tier_hours'] == 8  # Tier 3
assert result['factor_hours'] > 0
assert result['total_hours'] == result['base_hours'] + result['tier_hours'] + result['factor_hours']
assert 'tier_name' in result
assert result['complexity_score'] >= 34 and result['complexity_score'] <= 50
print('All assertions passed')
"
```
  </verify>
  <done>
Config JSON exists with 6 tiers, 8 factors, and base time per category. Calculator correctly sums base_hours + tier_hours + factor_hours and returns full breakdown dict. All values configurable without code changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update HybridQuoteRequest schema with new tier + factor fields</name>
  <files>backend/app/schemas/hybrid_quote.py</files>
  <action>
Update `HybridQuoteRequest` in `backend/app/schemas/hybrid_quote.py` to add new fields ALONGSIDE existing ones for backward compatibility.

Add these new Optional fields to HybridQuoteRequest (after the existing fields, before has_chimney):

```python
# NEW: Tier-based complexity (Phase 21)
complexity_tier: Optional[int] = Field(
    default=None,
    ge=1,
    le=6,
    description="Complexity tier (1-6). When provided, uses new tier-based system."
)
complexity_score: Optional[int] = Field(
    default=None,
    ge=0,
    le=100,
    description="Tier-based complexity score (0-100). Auto-calculated from tier if not provided."
)

# NEW: Factor checklist (Phase 21) - 8 factors replacing old 6 slider values
factor_roof_pitch: Optional[str] = Field(
    default=None,
    description="Roof pitch category: flat|low|medium|steep|very_steep"
)
factor_access_difficulty: Optional[List[str]] = Field(
    default=None,
    description="Access difficulty checklist items (e.g., no_crane, narrow_driveway)"
)
factor_demolition: Optional[str] = Field(
    default=None,
    description="Demolition type: none|single_layer|multi_layer|structural"
)
factor_penetrations_count: Optional[int] = Field(
    default=None,
    ge=0,
    le=100,
    description="Number of roof penetrations (vents, pipes, skylights)"
)
factor_security: Optional[List[str]] = Field(
    default=None,
    description="Security requirements checklist (e.g., harness, scaffolding)"
)
factor_material_removal: Optional[str] = Field(
    default=None,
    description="Material removal type: none|standard|heavy|hazardous"
)
factor_roof_sections_count: Optional[int] = Field(
    default=None,
    ge=1,
    le=20,
    description="Number of distinct roof sections"
)
factor_previous_layers_count: Optional[int] = Field(
    default=None,
    ge=0,
    le=10,
    description="Number of existing layers to remove"
)

# NEW: Manual hour override (upward only)
manual_extra_hours: Optional[float] = Field(
    default=None,
    ge=0,
    description="Manual extra hours added by estimator (upward override only)"
)
```

Add `from typing import List, Literal, Optional` (List is already imported, just ensure it's there).

Make the existing `complexity_aggregate` field Optional with default None:
```python
complexity_aggregate: Optional[int] = Field(
    default=None,
    ge=0,
    le=56,
    description="LEGACY: Sum of 6 complexity factors (0-56). Use complexity_tier for new quotes."
)
```

Make the existing 6 slider fields (access_difficulty, roof_pitch, penetrations, material_removal, safety_concerns, timeline_constraints) all Optional with default None:
```python
access_difficulty: Optional[int] = Field(default=None, ge=0, le=10, ...)
roof_pitch: Optional[int] = Field(default=None, ge=0, le=8, ...)
# ... same for all 6
```

Update the `validate_complexity_sum` model_validator to SKIP validation when using the new tier system (when complexity_tier is provided) or when old fields are all None:
```python
@model_validator(mode="after")
def validate_complexity(self) -> "HybridQuoteRequest":
    """Validate complexity - either old slider system or new tier system."""
    # New tier system: skip old sum validation
    if self.complexity_tier is not None:
        return self

    # Old system: validate sum if aggregate and factors are provided
    if self.complexity_aggregate is not None:
        old_fields = [
            self.access_difficulty, self.roof_pitch, self.penetrations,
            self.material_removal, self.safety_concerns, self.timeline_constraints
        ]
        if all(f is not None for f in old_fields):
            calculated_sum = sum(old_fields)
            tolerance = max(1, int(calculated_sum * 0.05))
            if abs(self.complexity_aggregate - calculated_sum) > tolerance:
                raise ValueError(
                    f"complexity_aggregate ({self.complexity_aggregate}) must equal sum of 6 factors "
                    f"({calculated_sum}) within 5% tolerance"
                )
    return self
```

Update the json_schema_extra examples to show both old and new request formats.

IMPORTANT: Do NOT rename the existing validator method -- rename it to `validate_complexity` (from `validate_complexity_sum`) to reflect its broader scope.
  </action>
  <verify>
```bash
cd backend && python -c "
from app.schemas.hybrid_quote import HybridQuoteRequest

# Test OLD format still works
old = HybridQuoteRequest(
    sqft=1500, category='Bardeaux',
    complexity_aggregate=28,
    access_difficulty=5, roof_pitch=4, penetrations=5,
    material_removal=4, safety_concerns=5, timeline_constraints=5,
    material_lines=5, labor_lines=2
)
print(f'Old format OK: aggregate={old.complexity_aggregate}')

# Test NEW format works
new = HybridQuoteRequest(
    sqft=1500, category='Bardeaux',
    complexity_tier=3, complexity_score=42,
    factor_roof_pitch='steep',
    factor_access_difficulty=['no_crane', 'narrow_driveway'],
    factor_demolition='multi_layer',
    factor_penetrations_count=4,
    factor_security=['harness'],
    factor_material_removal='standard',
    factor_roof_sections_count=4,
    factor_previous_layers_count=2,
    material_lines=5, labor_lines=2
)
print(f'New format OK: tier={new.complexity_tier}, score={new.complexity_score}')

# Test minimal request (no complexity at all)
minimal = HybridQuoteRequest(
    sqft=1500, category='Bardeaux',
    material_lines=5, labor_lines=2
)
print(f'Minimal format OK: tier={minimal.complexity_tier}, agg={minimal.complexity_aggregate}')

print('All schema tests passed')
"
```
  </verify>
  <done>
HybridQuoteRequest accepts three modes: (1) old slider format with 6 factors + aggregate, (2) new tier format with tier + factor checklist, (3) minimal format with no complexity. All old API consumers continue working. New fields are all Optional.
  </done>
</task>

</tasks>

<verification>
1. `complexity_tiers_config.json` loads correctly with 6 tiers and 8 factors
2. `calculate_complexity_hours()` returns correct hour breakdown for sample inputs
3. `HybridQuoteRequest` accepts old format (backward compatible)
4. `HybridQuoteRequest` accepts new tier format
5. No import errors in either new module
</verification>

<success_criteria>
- Config JSON exists with 6 tiers, 8 factors, base time per category
- Calculator service produces correct base + tier + factor hour totals
- Backend schema accepts both old and new complexity input formats
- No breaking changes to existing API consumers
</success_criteria>

<output>
After completion, create `.planning/phases/21-complexity-system-rebuild/21-01-SUMMARY.md`
</output>
