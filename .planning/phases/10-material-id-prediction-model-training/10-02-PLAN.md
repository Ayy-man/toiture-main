---
phase: 10-material-id-prediction
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - backend/app/services/material_predictor.py
  - backend/app/schemas/materials.py
  - backend/app/routers/estimate.py
autonomous: true

must_haves:
  truths:
    - "POST /estimate/materials returns predicted material IDs and quantities"
    - "POST /estimate/full returns price estimate plus materials"
    - "Response time < 2 seconds for /estimate/materials"
    - "Response time < 5 seconds for /estimate/full"
    - "Models load lazily on first request"
  artifacts:
    - path: "backend/app/services/material_predictor.py"
      provides: "MaterialPredictor class with lazy loading"
      min_lines: 80
      exports: ["predict_materials"]
    - path: "backend/app/schemas/materials.py"
      provides: "Pydantic request/response models"
      min_lines: 30
      exports: ["MaterialEstimateRequest", "MaterialPrediction", "MaterialEstimateResponse", "FullEstimateResponse"]
    - path: "backend/app/routers/estimate.py"
      provides: "New endpoints"
      contains: ["/estimate/materials", "/estimate/full"]
  key_links:
    - from: "backend/app/routers/estimate.py"
      to: "backend/app/services/material_predictor.py"
      via: "import predict_materials"
      pattern: "from app\\.services\\.material_predictor import"
    - from: "backend/app/services/material_predictor.py"
      to: "backend/app/models/"
      via: "joblib.load"
      pattern: "joblib\\.load.*material"
---

<objective>
Create prediction service and FastAPI endpoints for material predictions

Purpose: Expose trained material models via REST API for the admin dashboard
Output: Two new endpoints: /estimate/materials and /estimate/full
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-material-id-prediction-model-training/10-01-SUMMARY.md

# Existing patterns to follow
@backend/app/services/predictor.py (lazy loading pattern - CRITICAL)
@backend/app/routers/estimate.py (endpoint patterns)
@backend/app/schemas/estimate.py (Pydantic patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for material endpoints</name>
  <files>backend/app/schemas/materials.py</files>
  <action>
Create new schemas file with:

```python
"""Pydantic models for material prediction endpoints."""

from typing import List, Optional, Literal
from pydantic import BaseModel, Field

class MaterialEstimateRequest(BaseModel):
    """Request for material prediction."""
    sqft: float = Field(gt=0, le=100000, description="Square footage of roof")
    category: str = Field(description="Job category (Bardeaux, Elastomere, etc.)")
    complexity: int = Field(default=10, ge=1, le=100)
    has_chimney: bool = Field(default=False)
    has_skylights: bool = Field(default=False)
    material_lines: int = Field(default=5, ge=0, le=100)
    labor_lines: int = Field(default=2, ge=0, le=50)
    has_subs: bool = Field(default=False)
    quoted_total: Optional[float] = Field(default=None, description="If known, helps prediction")

class MaterialPrediction(BaseModel):
    """Single material prediction."""
    material_id: int
    quantity: float
    unit_price: float
    total: float
    confidence: Literal["HIGH", "MEDIUM", "LOW"]

class MaterialEstimateResponse(BaseModel):
    """Response for /estimate/materials endpoint."""
    materials: List[MaterialPrediction]
    total_materials_cost: float
    model_info: str
    applied_rules: List[str] = []  # Co-occurrence rules that fired

class FullEstimateResponse(BaseModel):
    """Response for /estimate/full endpoint."""
    # Price estimate (from existing predictor)
    estimate: float
    range_low: float
    range_high: float
    confidence: Literal["HIGH", "MEDIUM", "LOW"]
    model: str
    # Material prediction
    materials: List[MaterialPrediction]
    total_materials_cost: float
    applied_rules: List[str] = []
```

Normalize category validator to handle "Elastomere" -> "Elastomere" (without accent for material model since training data uses accented version).
  </action>
  <verify>
```bash
cd /Users/aymanbaig/Desktop/Toiture-P1/backend && python -c "from app.schemas.materials import MaterialEstimateRequest, MaterialEstimateResponse, FullEstimateResponse; print('Schemas OK')"
```
  </verify>
  <done>
- MaterialEstimateRequest schema created with all required fields
- MaterialPrediction, MaterialEstimateResponse, FullEstimateResponse schemas created
- Imports work without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create material predictor service with lazy loading</name>
  <files>backend/app/services/material_predictor.py</files>
  <action>
Create prediction service following the EXACT pattern from predictor.py:

```python
"""Material ID and quantity prediction service.

Uses lazy loading to reduce memory footprint at startup.
"""

import gc
import json
import logging
from pathlib import Path
from typing import List, Dict, Any

import numpy as np

logger = logging.getLogger(__name__)

# Module-level storage (shared across requests)
_models: dict = {}
_loaded: bool = False

MODEL_DIR = Path(__file__).parent.parent / "models"


def _ensure_models_loaded() -> None:
    """Lazy-load material prediction models on first use."""
    global _loaded
    if _loaded:
        return

    import joblib

    logger.info("Lazy-loading material prediction models (first use)...")

    _models["selector"] = joblib.load(MODEL_DIR / "material_selector.pkl")
    _models["binarizer"] = joblib.load(MODEL_DIR / "material_binarizer.pkl")
    _models["quantity"] = joblib.load(MODEL_DIR / "quantity_regressors.pkl")
    _models["category_encoder"] = joblib.load(MODEL_DIR / "category_encoder_material.pkl")

    with open(MODEL_DIR / "co_occurrence_rules.json") as f:
        _models["rules"] = json.load(f)

    with open(MODEL_DIR / "feature_triggers.json") as f:
        _models["triggers"] = json.load(f)

    with open(MODEL_DIR / "material_prices.json") as f:
        _models["prices"] = json.load(f)

    gc.collect()
    _loaded = True
    logger.info("Material prediction models loaded successfully")


def predict_materials(
    sqft: float,
    category: str,
    complexity: int = 10,
    has_chimney: bool = False,
    has_skylights: bool = False,
    material_lines: int = 5,
    labor_lines: int = 2,
    has_subs: bool = False,
    quoted_total: float = None,
) -> Dict[str, Any]:
    """Predict material IDs and quantities for a roofing job.

    Returns dict with:
    - materials: List of {material_id, quantity, unit_price, total, confidence}
    - total_materials_cost: Sum of all material totals
    - model_info: Description of model used
    - applied_rules: List of co-occurrence rules that fired
    """
    _ensure_models_loaded()

    # Encode category
    try:
        cat_enc = _models["category_encoder"].transform([category])[0]
    except ValueError:
        cat_enc = 0  # Unknown category

    # Build feature vector (same order as training)
    X = np.array([[
        sqft,
        complexity,
        quoted_total if quoted_total else sqft * 15,  # Estimate if not provided
        1 if has_chimney else 0,
        1 if has_skylights else 0,
        material_lines,
        labor_lines,
        1 if has_subs else 0,
        cat_enc,
    ]])

    # Predict material IDs
    probs = _models["selector"].predict_proba(X)[0]
    # Use 0.3 threshold (tuned during training)
    predicted_binary = (probs > 0.3).astype(int).reshape(1, -1)
    predicted_ids = _models["binarizer"].inverse_transform(predicted_binary)[0]
    predicted_ids = list(predicted_ids)

    # Apply feature triggers
    if has_chimney and "chimney_materials" in _models["triggers"]:
        for mat_id in _models["triggers"]["chimney_materials"]:
            if mat_id not in predicted_ids:
                predicted_ids.append(mat_id)

    if has_skylights and "skylight_materials" in _models["triggers"]:
        for mat_id in _models["triggers"]["skylight_materials"]:
            if mat_id not in predicted_ids:
                predicted_ids.append(mat_id)

    # Apply co-occurrence rules
    applied_rules = []
    for rule in _models["rules"]:
        if rule["antecedent"] in predicted_ids and rule["consequent"] not in predicted_ids:
            predicted_ids.append(rule["consequent"])
            applied_rules.append(f"{rule['antecedent']} -> {rule['consequent']} (conf={rule['confidence']:.2f})")

    # Predict quantities for each material
    materials = []
    for mat_id in predicted_ids:
        mat_id_str = str(mat_id)

        # Get quantity from regressor or default to 1
        if mat_id_str in _models["quantity"]:
            qty = max(1, round(_models["quantity"][mat_id_str].predict(X)[0], 1))
            confidence = "HIGH"
        else:
            qty = 1.0
            confidence = "LOW"

        # Get unit price from lookup
        unit_price = _models["prices"].get(mat_id_str, 50.0)
        total = round(qty * unit_price, 2)

        materials.append({
            "material_id": mat_id,
            "quantity": qty,
            "unit_price": unit_price,
            "total": total,
            "confidence": confidence,
        })

    # Sort by total (descending) for usability
    materials.sort(key=lambda x: x["total"], reverse=True)

    total_cost = sum(m["total"] for m in materials)

    return {
        "materials": materials,
        "total_materials_cost": round(total_cost, 2),
        "model_info": "OneVsRest + GradientBoosting (v1)",
        "applied_rules": applied_rules,
    }
```

CRITICAL: Follow the exact lazy loading pattern from predictor.py with module-level _models dict and _ensure_models_loaded() function.
  </action>
  <verify>
```bash
cd /Users/aymanbaig/Desktop/Toiture-P1/backend && python -c "
from app.services.material_predictor import predict_materials
result = predict_materials(sqft=1500, category='Bardeaux', complexity=15, has_chimney=True)
print(f'Predicted {len(result[\"materials\"])} materials, total cost: \${result[\"total_materials_cost\"]:,.2f}')
"
```
  </verify>
  <done>
- material_predictor.py created with lazy loading pattern
- predict_materials function works and returns expected structure
- Models load successfully on first call
  </done>
</task>

<task type="auto">
  <name>Task 3: Add material endpoints to estimate router</name>
  <files>backend/app/routers/estimate.py</files>
  <action>
Add two new endpoints to the existing estimate.py router:

1. **Import new modules** at top of file:
```python
from app.schemas.materials import (
    MaterialEstimateRequest,
    MaterialEstimateResponse,
    MaterialPrediction,
    FullEstimateResponse,
)
from app.services.material_predictor import predict_materials
```

2. **Add POST /estimate/materials endpoint:**
```python
@router.post("/estimate/materials", response_model=MaterialEstimateResponse)
def predict_materials_endpoint(request: MaterialEstimateRequest):
    """Predict material IDs and quantities for roofing job.

    Uses multi-label classifier for ID selection and per-material regressors
    for quantity prediction. Applies co-occurrence rules and feature triggers.
    """
    try:
        result = predict_materials(
            sqft=request.sqft,
            category=request.category,
            complexity=request.complexity,
            has_chimney=request.has_chimney,
            has_skylights=request.has_skylights,
            material_lines=request.material_lines,
            labor_lines=request.labor_lines,
            has_subs=request.has_subs,
            quoted_total=request.quoted_total,
        )

        return MaterialEstimateResponse(
            materials=[MaterialPrediction(**m) for m in result["materials"]],
            total_materials_cost=result["total_materials_cost"],
            model_info=result["model_info"],
            applied_rules=result["applied_rules"],
        )
    except Exception as e:
        logger.error(f"Material prediction error: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

3. **Add POST /estimate/full endpoint:**
```python
@router.post("/estimate/full", response_model=FullEstimateResponse)
def create_full_estimate(request: MaterialEstimateRequest):
    """Generate complete estimate with price prediction AND material list.

    Combines:
    - Price estimate from existing ML model
    - Material predictions from material model
    """
    try:
        # Get price prediction (existing)
        price_result = predict(
            sqft=request.sqft,
            category=request.category,
            material_lines=request.material_lines,
            labor_lines=request.labor_lines,
            has_subs=1 if request.has_subs else 0,
            complexity=request.complexity,
        )

        # Get material predictions (new)
        material_result = predict_materials(
            sqft=request.sqft,
            category=request.category,
            complexity=request.complexity,
            has_chimney=request.has_chimney,
            has_skylights=request.has_skylights,
            material_lines=request.material_lines,
            labor_lines=request.labor_lines,
            has_subs=request.has_subs,
            quoted_total=request.quoted_total,
        )

        return FullEstimateResponse(
            estimate=price_result["estimate"],
            range_low=price_result["range_low"],
            range_high=price_result["range_high"],
            confidence=price_result["confidence"],
            model=price_result["model"],
            materials=[MaterialPrediction(**m) for m in material_result["materials"]],
            total_materials_cost=material_result["total_materials_cost"],
            applied_rules=material_result["applied_rules"],
        )
    except Exception as e:
        logger.error(f"Full estimate error: {e}")
        raise HTTPException(status_code=500, detail=str(e))
```

Do NOT modify existing /estimate or /estimate/stream endpoints.
  </action>
  <verify>
```bash
cd /Users/aymanbaig/Desktop/Toiture-P1/backend && python -m pytest app/tests/ -v --tb=short 2>/dev/null || python -c "
import json
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

# Test /estimate/materials
resp = client.post('/estimate/materials', json={
    'sqft': 1500,
    'category': 'Bardeaux',
    'complexity': 15,
    'has_chimney': True,
    'has_skylights': False
})
print(f'/estimate/materials: {resp.status_code}')
if resp.status_code == 200:
    data = resp.json()
    print(f'  Materials: {len(data[\"materials\"])}, Total: \${data[\"total_materials_cost\"]:,.2f}')

# Test /estimate/full
resp = client.post('/estimate/full', json={
    'sqft': 1500,
    'category': 'Bardeaux',
    'complexity': 15,
    'has_chimney': True,
    'has_skylights': False
})
print(f'/estimate/full: {resp.status_code}')
if resp.status_code == 200:
    data = resp.json()
    print(f'  Estimate: \${data[\"estimate\"]:,.2f}, Materials: {len(data[\"materials\"])}')
"
```
  </verify>
  <done>
- /estimate/materials endpoint returns 200 with materials list
- /estimate/full endpoint returns 200 with price + materials
- Existing /estimate and /estimate/stream endpoints still work
  </done>
</task>

</tasks>

<verification>
1. Schemas import: `python -c "from app.schemas.materials import *"`
2. Predictor service works: `python -c "from app.services.material_predictor import predict_materials"`
3. Endpoints respond:
   - `curl -X POST http://localhost:8000/estimate/materials -H "Content-Type: application/json" -d '{"sqft": 1500, "category": "Bardeaux"}'`
   - `curl -X POST http://localhost:8000/estimate/full -H "Content-Type: application/json" -d '{"sqft": 1500, "category": "Bardeaux"}'`
4. Response times:
   - /estimate/materials < 2 seconds
   - /estimate/full < 5 seconds
5. Existing tests still pass: `pytest app/tests/ -v`
</verification>

<success_criteria>
- POST /estimate/materials returns predicted materials with quantities
- POST /estimate/full returns price estimate + materials
- Response time < 2s for /estimate/materials
- Response time < 5s for /estimate/full
- Models load lazily (no startup penalty)
- Existing endpoints unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/10-material-id-prediction-model-training/10-02-SUMMARY.md`
</output>
