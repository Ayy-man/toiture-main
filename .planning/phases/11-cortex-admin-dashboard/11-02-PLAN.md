---
phase: 11-cortex-admin-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/routers/quotes.py
  - backend/app/routers/customers.py
  - backend/app/routers/dashboard.py
  - backend/app/schemas/quotes.py
  - backend/app/schemas/customers.py
  - backend/app/schemas/dashboard.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "API returns paginated quotes with filters"
    - "API searches customers by name"
    - "API returns dashboard metrics aggregations"
    - "All endpoints return 503 when Supabase unavailable"
  artifacts:
    - path: "backend/app/routers/quotes.py"
      provides: "GET /quotes with pagination and filters"
      min_lines: 50
    - path: "backend/app/routers/customers.py"
      provides: "GET /customers/search with full-text search"
      min_lines: 30
    - path: "backend/app/routers/dashboard.py"
      provides: "GET /dashboard/metrics and /dashboard/charts"
      min_lines: 60
  key_links:
    - from: "backend/app/main.py"
      to: "backend/app/routers/quotes.py"
      via: "app.include_router"
      pattern: "include_router.*quotes"
    - from: "backend/app/routers/quotes.py"
      to: "backend/app/services/supabase_client.py"
      via: "get_supabase() call"
      pattern: "get_supabase"
---

<objective>
Create backend API endpoints for the admin dashboard: quotes browsing, customer search, and dashboard metrics.

Purpose: The Historique, Clients, and Apercu tabs need backend data. These endpoints query the Supabase quotes table (historical job data) and provide aggregations for the dashboard.

Output: Three new routers with paginated quotes, customer search, and dashboard metrics endpoints.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-cortex-admin-dashboard/11-RESEARCH.md

Reference existing patterns:
@backend/app/routers/feedback.py (Supabase query patterns, 503 handling)
@backend/app/routers/estimate.py (router structure)
@backend/app/services/supabase_client.py (get_supabase pattern)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create quotes endpoint with pagination and filters</name>
  <files>
    backend/app/schemas/quotes.py
    backend/app/routers/quotes.py
  </files>
  <action>
1. Create `backend/app/schemas/quotes.py`:
   ```python
   from pydantic import BaseModel
   from typing import List, Optional
   from datetime import datetime

   class QuoteItem(BaseModel):
       id: str
       client_name: Optional[str] = None
       category: Optional[str] = None
       city: Optional[str] = None
       sqft: Optional[float] = None
       total_price: Optional[float] = None
       margin_percent: Optional[float] = None
       created_at: str

   class PaginatedQuotes(BaseModel):
       items: List[QuoteItem]
       total: int
       page: int
       per_page: int
       total_pages: int

   class QuoteFilters(BaseModel):
       category: Optional[str] = None
       city: Optional[str] = None
       min_sqft: Optional[float] = None
       max_sqft: Optional[float] = None
       min_price: Optional[float] = None
       max_price: Optional[float] = None
       start_date: Optional[str] = None
       end_date: Optional[str] = None
   ```

2. Create `backend/app/routers/quotes.py`:
   - Import APIRouter, Query, HTTPException from fastapi
   - Import get_supabase from app.services.supabase_client
   - Import schemas from app.schemas.quotes
   - Create router with prefix="/quotes" and tags=["quotes"]

   GET "/" endpoint:
   - Parameters: page (default 1, ge=1), per_page (default 20, ge=1, le=100)
   - Filter parameters: category, city, min_sqft, max_sqft, min_price, max_price, start_date, end_date
   - Return 503 if get_supabase() returns None
   - Build Supabase query with .select("*", count="exact")
   - Apply filters using .eq(), .ilike(), .gte(), .lte() based on provided params
   - Apply pagination with .range(offset, offset + per_page - 1)
   - Order by created_at desc
   - Calculate total_pages: (total + per_page - 1) // per_page
   - Return PaginatedQuotes

   Note: The quotes table in Supabase may be the same as estimates table or a separate historical data table. Query estimates table first, adapt field names as needed (ai_estimate -> total_price if needed).
  </action>
  <verify>
```bash
cd /Users/aymanbaig/Desktop/Toiture-P1/backend
python -c "from app.schemas.quotes import QuoteItem, PaginatedQuotes; print('Schemas OK')"
python -c "from app.routers.quotes import router; print('Router OK')"
```
  </verify>
  <done>
- QuoteItem and PaginatedQuotes schemas defined
- GET /quotes endpoint handles pagination (page, per_page)
- Filters work: category, city, sqft range, price range, date range
- Returns 503 when Supabase unavailable
  </done>
</task>

<task type="auto">
  <name>Task 2: Create customers search endpoint</name>
  <files>
    backend/app/schemas/customers.py
    backend/app/routers/customers.py
  </files>
  <action>
1. Create `backend/app/schemas/customers.py`:
   ```python
   from pydantic import BaseModel
   from typing import List, Optional

   class CustomerResult(BaseModel):
       id: str
       name: str
       city: Optional[str] = None
       total_quotes: int = 0
       lifetime_value: float = 0.0
       segment: str = "New"  # "VIP", "Regular", "New"

   class CustomerDetail(BaseModel):
       id: str
       name: str
       city: Optional[str] = None
       phone: Optional[str] = None
       email: Optional[str] = None
       total_quotes: int = 0
       lifetime_value: float = 0.0
       segment: str = "New"
       quotes: List[dict] = []  # Recent quote history
   ```

2. Create `backend/app/routers/customers.py`:
   - Import APIRouter, Query, HTTPException from fastapi
   - Import get_supabase
   - Import schemas
   - Create router with prefix="/customers" and tags=["customers"]

   GET "/search" endpoint:
   - Parameters: q (str, min_length=2), limit (default 10, le=50)
   - Return 503 if Supabase unavailable
   - Use Supabase .ilike("client_name", f"%{q}%") for simple search
   - Alternative: If a dedicated customers table exists with FTS index, use .textSearch()
   - Group by client_name to get aggregates (total_quotes, lifetime_value)
   - Determine segment based on lifetime_value:
     - VIP: lifetime_value > 50000
     - Regular: lifetime_value > 10000
     - New: otherwise
   - Return List[CustomerResult]

   GET "/{customer_id}" endpoint:
   - Return customer detail with quote history
   - Query quotes/estimates where client matches
   - Calculate aggregates
   - Return CustomerDetail

   Note: Customer data likely comes from quotes table client_name field. May need to aggregate from quotes rather than having dedicated customers table.
  </action>
  <verify>
```bash
cd /Users/aymanbaig/Desktop/Toiture-P1/backend
python -c "from app.schemas.customers import CustomerResult, CustomerDetail; print('Schemas OK')"
python -c "from app.routers.customers import router; print('Router OK')"
```
  </verify>
  <done>
- CustomerResult and CustomerDetail schemas defined
- GET /customers/search searches by name (case-insensitive)
- Search returns within <1 second for typical queries
- GET /customers/{id} returns full customer detail with quote history
- Segment badge calculated from lifetime value
  </done>
</task>

<task type="auto">
  <name>Task 3: Create dashboard metrics and charts endpoints</name>
  <files>
    backend/app/schemas/dashboard.py
    backend/app/routers/dashboard.py
    backend/app/main.py
  </files>
  <action>
1. Create `backend/app/schemas/dashboard.py`:
   ```python
   from pydantic import BaseModel
   from typing import List, Optional

   class DashboardMetrics(BaseModel):
       total_revenue: float
       total_quotes: int
       average_margin: float
       active_clients: int
       period_start: Optional[str] = None
       period_end: Optional[str] = None

   class RevenueByYear(BaseModel):
       year: int
       revenue: float
       quote_count: int

   class RevenueByCategory(BaseModel):
       category: str
       revenue: float
       quote_count: int
       percentage: float

   class MonthlyTrend(BaseModel):
       month: str  # "2024-01" format
       revenue: float
       quote_count: int

   class TopClient(BaseModel):
       name: str
       total_spent: float
       quote_count: int

   class DashboardCharts(BaseModel):
       revenue_by_year: List[RevenueByYear]
       revenue_by_category: List[RevenueByCategory]
       monthly_trend: List[MonthlyTrend]
       top_clients: List[TopClient]
   ```

2. Create `backend/app/routers/dashboard.py`:
   - Import APIRouter, Query, HTTPException
   - Import get_supabase
   - Import schemas
   - Create router with prefix="/dashboard" and tags=["dashboard"]

   GET "/metrics" endpoint:
   - Parameters: start_date (optional), end_date (optional)
   - Return 503 if Supabase unavailable
   - Query quotes table with date filters
   - Aggregate: SUM(total_price) as total_revenue, COUNT(*) as total_quotes
   - Calculate average_margin from margin_percent column or compute (price - cost) / price
   - Count distinct client_name as active_clients
   - Return DashboardMetrics

   GET "/charts" endpoint:
   - Parameters: start_date, end_date (optional)
   - Return 503 if Supabase unavailable
   - Query for revenue_by_year: GROUP BY EXTRACT(year FROM created_at)
   - Query for revenue_by_category: GROUP BY category
   - Query for monthly_trend: GROUP BY to_char(created_at, 'YYYY-MM')
   - Query for top_clients: GROUP BY client_name ORDER BY SUM(total_price) DESC LIMIT 10
   - Return DashboardCharts

   Note: May need to use Supabase RPC functions for complex aggregations. If direct queries too slow, create RPC functions.

3. Register all new routers in `backend/app/main.py`:
   - Import quotes router, customers router, dashboard router
   - Add app.include_router() for each
   - Place after existing router includes
  </action>
  <verify>
```bash
cd /Users/aymanbaig/Desktop/Toiture-P1/backend
python -c "from app.schemas.dashboard import DashboardMetrics, DashboardCharts; print('Schemas OK')"
python -c "from app.routers.dashboard import router; print('Router OK')"
grep "include_router" backend/app/main.py | wc -l  # Should show increased count
```
  </verify>
  <done>
- DashboardMetrics and DashboardCharts schemas defined
- GET /dashboard/metrics returns KPIs with optional date filtering
- GET /dashboard/charts returns chart data (revenue by year/category, trends, top clients)
- All 3 new routers registered in main.py
  </done>
</task>

</tasks>

<verification>
1. Start backend server and test endpoints:
```bash
cd backend
uvicorn app.main:app --reload &
sleep 3

# Test quotes endpoint
curl -s "http://localhost:8000/quotes?page=1&per_page=5" | python -m json.tool | head -20

# Test customers search
curl -s "http://localhost:8000/customers/search?q=test" | python -m json.tool

# Test dashboard metrics
curl -s "http://localhost:8000/dashboard/metrics" | python -m json.tool

# Test dashboard charts
curl -s "http://localhost:8000/dashboard/charts" | python -m json.tool
```

2. Verify 503 response when Supabase not configured (unset env vars and test)
</verification>

<success_criteria>
- GET /quotes returns paginated list with total count
- GET /quotes?category=X filters correctly
- GET /customers/search?q=name returns matching customers
- GET /dashboard/metrics returns revenue, quotes count, margin, clients
- GET /dashboard/charts returns chart data arrays
- All endpoints return 503 when Supabase unavailable
- Backend starts without import errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-cortex-admin-dashboard/11-02-SUMMARY.md`
</output>
