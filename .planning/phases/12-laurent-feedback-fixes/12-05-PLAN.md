# 12-05: Three Quote Options (Basic/Standard/Premium)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Generate 3 price tiers for each quote (Basic/Standard/Premium) to give clients choice and anchor them toward the middle option.

**Architecture:** Extend estimate response to include 3 tiers with multipliers, update predictor to generate tier variants, create frontend tier selection/display component.

**Tech Stack:** FastAPI (Pydantic), TypeScript, React, shadcn/ui

---

## Context

Laurent's request: "System should generate 3 price options for each quote."

### Tier Strategy

| Tier | Purpose | Multiplier | Description |
|------|---------|------------|-------------|
| **BASIC** | Budget option | 0.85x | Minimum acceptable, essential work only |
| **STANDARD** | Recommended | 1.0x | Full service, most common choice |
| **PREMIUM** | Best quality | 1.20x | Premium materials, extended warranty |

**Psychology:** Clients see 3 options, typically choose middle (Standard). Premium anchors the value higher, Basic provides safety net.

---

## Plan

### Task 1: Create Tier Configuration

**Files:**
- Create: `backend/app/config/quote_tiers.py`

**Step 1: Define tier configuration**

```python
# backend/app/config/quote_tiers.py
from enum import Enum
from pydantic import BaseModel, Field
from typing import Dict


class QuoteTier(str, Enum):
    """Quote tier options"""
    BASIC = "basic"
    STANDARD = "standard"
    PREMIUM = "premium"


class TierConfig(BaseModel):
    """Configuration for a single tier"""
    name: str
    name_fr: str  # French name
    multiplier: float = Field(description="Price multiplier relative to base estimate")
    materials_multiplier: float = Field(default=1.0, description="Materials cost multiplier")
    description: str
    description_fr: str  # French description
    includes: list[str]  # What's included
    includes_fr: list[str]  # French includes


TIER_CONFIGS: Dict[QuoteTier, TierConfig] = {
    QuoteTier.BASIC: TierConfig(
        name="Basic",
        name_fr="Essentiel",
        multiplier=0.85,
        materials_multiplier=0.90,
        description="Budget-friendly option with essential work only",
        description_fr="Option economique avec travaux essentiels seulement",
        includes=[
            "Standard materials",
            "Basic warranty (5 years)",
            "Standard cleanup",
        ],
        includes_fr=[
            "Materiaux standards",
            "Garantie de base (5 ans)",
            "Nettoyage standard",
        ],
    ),
    QuoteTier.STANDARD: TierConfig(
        name="Standard",
        name_fr="Standard",
        multiplier=1.0,
        materials_multiplier=1.0,
        description="Recommended option with full service",
        description_fr="Option recommandee avec service complet",
        includes=[
            "Quality materials",
            "Extended warranty (10 years)",
            "Thorough cleanup",
            "Progress photos",
        ],
        includes_fr=[
            "Materiaux de qualite",
            "Garantie prolongee (10 ans)",
            "Nettoyage complet",
            "Photos de progression",
        ],
    ),
    QuoteTier.PREMIUM: TierConfig(
        name="Premium",
        name_fr="Premium",
        multiplier=1.20,
        materials_multiplier=1.15,
        description="Best quality with premium materials and service",
        description_fr="Meilleure qualite avec materiaux et service premium",
        includes=[
            "Premium materials",
            "Lifetime warranty",
            "Professional cleanup",
            "Progress photos & video",
            "Priority scheduling",
            "Post-completion inspection",
        ],
        includes_fr=[
            "Materiaux premium",
            "Garantie a vie",
            "Nettoyage professionnel",
            "Photos et video de progression",
            "Planification prioritaire",
            "Inspection post-travaux",
        ],
    ),
}


def get_tier_config(tier: QuoteTier) -> TierConfig:
    """Get configuration for a tier"""
    return TIER_CONFIGS[tier]


def calculate_tier_price(base_price: float, tier: QuoteTier) -> float:
    """Calculate price for a specific tier"""
    config = get_tier_config(tier)
    return round(base_price * config.multiplier, 2)


def calculate_tier_materials(base_materials: float, tier: QuoteTier) -> float:
    """Calculate materials cost for a specific tier"""
    config = get_tier_config(tier)
    return round(base_materials * config.materials_multiplier, 2)
```

---

### Task 2: Update Backend Schemas

**Files:**
- Modify: `backend/app/schemas/estimate.py`

**Step 1: Add tier-related schemas**

```python
from app.config.quote_tiers import QuoteTier, TierConfig, TIER_CONFIGS


class TierEstimate(BaseModel):
    """Estimate for a single tier"""
    tier: QuoteTier
    name: str
    name_fr: str
    estimate: float
    range_low: float
    range_high: float
    materials_cost: Optional[float] = None
    description_fr: str
    includes_fr: list[str]
    is_recommended: bool = Field(default=False, description="True for Standard tier")


class TieredEstimateResponse(BaseModel):
    """Response with all three tier options"""
    # Base estimate (Standard tier)
    base_estimate: float
    confidence: str
    model: str
    similar_cases: List[SimilarCase] = []
    reasoning: Optional[str] = None
    complexity_breakdown: Optional[ComplexityBreakdown] = None

    # NEW: Three tier options
    tiers: List[TierEstimate]

    # Convenience accessors
    @property
    def basic(self) -> Optional[TierEstimate]:
        return next((t for t in self.tiers if t.tier == QuoteTier.BASIC), None)

    @property
    def standard(self) -> Optional[TierEstimate]:
        return next((t for t in self.tiers if t.tier == QuoteTier.STANDARD), None)

    @property
    def premium(self) -> Optional[TierEstimate]:
        return next((t for t in self.tiers if t.tier == QuoteTier.PREMIUM), None)


class EstimateRequest(BaseModel):
    """Updated request with optional tier selection"""
    sqft: float = Field(gt=0, le=100000)
    category: str
    material_lines: int = Field(default=5, ge=0, le=50)
    labor_lines: int = Field(default=2, ge=0, le=50)
    has_subs: bool = Field(default=False)
    complexity_factors: Optional[ComplexityFactors] = None
    complexity: Optional[int] = Field(default=None, ge=1, le=100)

    # NEW: Option to request specific tier only (for final quote)
    selected_tier: Optional[QuoteTier] = None

    # NEW: Include all tiers in response (default True)
    include_tiers: bool = Field(default=True)
```

---

### Task 3: Update Backend Router

**Files:**
- Modify: `backend/app/routers/estimate.py`

**Step 1: Update estimate endpoint to return tiers**

```python
from app.config.quote_tiers import (
    QuoteTier,
    TIER_CONFIGS,
    calculate_tier_price,
    calculate_tier_materials,
)
from app.schemas.estimate import TierEstimate, TieredEstimateResponse


def generate_tier_estimates(
    base_estimate: float,
    range_low: float,
    range_high: float,
    base_materials: Optional[float] = None,
) -> List[TierEstimate]:
    """Generate estimates for all three tiers"""
    tiers = []

    for tier in [QuoteTier.BASIC, QuoteTier.STANDARD, QuoteTier.PREMIUM]:
        config = TIER_CONFIGS[tier]
        tier_price = calculate_tier_price(base_estimate, tier)
        tier_materials = calculate_tier_materials(base_materials, tier) if base_materials else None

        # Calculate tier-specific ranges
        tier_range_low = round(range_low * config.multiplier, 2)
        tier_range_high = round(range_high * config.multiplier, 2)

        tiers.append(TierEstimate(
            tier=tier,
            name=config.name,
            name_fr=config.name_fr,
            estimate=tier_price,
            range_low=tier_range_low,
            range_high=tier_range_high,
            materials_cost=tier_materials,
            description_fr=config.description_fr,
            includes_fr=config.includes_fr,
            is_recommended=(tier == QuoteTier.STANDARD),
        ))

    return tiers


@router.post("/", response_model=TieredEstimateResponse)
async def create_estimate(request: EstimateRequest):
    """
    Create price estimate with three tier options.

    Returns Basic, Standard (recommended), and Premium pricing options.
    """
    try:
        ml_complexity = request.get_ml_complexity()

        # Get base prediction (Standard tier)
        result = predictor.predict(
            sqft=request.sqft,
            category=request.category,
            material_lines=request.material_lines,
            labor_lines=request.labor_lines,
            has_subs=request.has_subs,
            complexity=ml_complexity,
        )

        base_estimate = result["estimate"]
        range_low = result["range_low"]
        range_high = result["range_high"]

        # Generate all three tiers
        tiers = []
        if request.include_tiers:
            tiers = generate_tier_estimates(
                base_estimate=base_estimate,
                range_low=range_low,
                range_high=range_high,
            )

        # Build complexity breakdown
        complexity_breakdown = None
        if request.complexity_factors:
            complexity_breakdown = ComplexityBreakdown(
                factors=request.complexity_factors,
                total_score=request.complexity_factors.total_score,
                normalized_score=request.complexity_factors.normalized_score,
            )

        # Get similar cases
        query_text = build_query_text(
            sqft=request.sqft,
            category=request.category,
            complexity=ml_complexity,
        )
        similar_cases = await get_similar_cases(query_text)

        # Save to database
        await save_estimate(
            request=request,
            result=result,
            selected_tier=request.selected_tier,
        )

        return TieredEstimateResponse(
            base_estimate=base_estimate,
            confidence=result["confidence"],
            model=result["model"],
            similar_cases=similar_cases,
            complexity_breakdown=complexity_breakdown,
            tiers=tiers,
        )

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

---

### Task 4: Create Frontend Types

**Files:**
- Create: `frontend/src/types/quote-tiers.ts`

**Step 1: Define tier types**

```typescript
// frontend/src/types/quote-tiers.ts

export type QuoteTier = "basic" | "standard" | "premium";

export interface TierEstimate {
  tier: QuoteTier;
  name: string;
  name_fr: string;
  estimate: number;
  range_low: number;
  range_high: number;
  materials_cost?: number;
  description_fr: string;
  includes_fr: string[];
  is_recommended: boolean;
}

export interface TieredEstimateResponse {
  base_estimate: number;
  confidence: string;
  model: string;
  similar_cases: any[];
  reasoning?: string;
  complexity_breakdown?: any;
  tiers: TierEstimate[];
}

export const TIER_COLORS: Record<QuoteTier, string> = {
  basic: "border-slate-300 bg-slate-50",
  standard: "border-[#8B2323] bg-red-50 ring-2 ring-[#8B2323]",
  premium: "border-amber-400 bg-amber-50",
};

export const TIER_BADGE_COLORS: Record<QuoteTier, string> = {
  basic: "bg-slate-200 text-slate-700",
  standard: "bg-[#8B2323] text-white",
  premium: "bg-amber-500 text-white",
};
```

---

### Task 5: Create Tier Selection Component

**Files:**
- Create: `frontend/src/components/estimateur/tier-options.tsx`

**Step 1: Create the component**

```tsx
// frontend/src/components/estimateur/tier-options.tsx
"use client";

import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Check, Star, Sparkles } from "lucide-react";
import {
  TierEstimate,
  QuoteTier,
  TIER_COLORS,
  TIER_BADGE_COLORS,
} from "@/types/quote-tiers";
import { fr } from "@/lib/i18n/fr";

interface TierOptionsProps {
  tiers: TierEstimate[];
  onSelect?: (tier: QuoteTier) => void;
  selectedTier?: QuoteTier;
}

const TIER_ICONS: Record<QuoteTier, React.ReactNode> = {
  basic: null,
  standard: <Star className="h-4 w-4" />,
  premium: <Sparkles className="h-4 w-4" />,
};

function formatCurrency(value: number): string {
  return new Intl.NumberFormat("fr-CA", {
    style: "currency",
    currency: "CAD",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value);
}

export function TierOptions({ tiers, onSelect, selectedTier }: TierOptionsProps) {
  const [hoveredTier, setHoveredTier] = useState<QuoteTier | null>(null);

  return (
    <div className="grid gap-4 md:grid-cols-3">
      {tiers.map((tier) => {
        const isSelected = selectedTier === tier.tier;
        const isRecommended = tier.is_recommended;
        const Icon = TIER_ICONS[tier.tier];

        return (
          <Card
            key={tier.tier}
            className={`relative cursor-pointer transition-all duration-200 ${
              TIER_COLORS[tier.tier]
            } ${isSelected ? "scale-105 shadow-lg" : "hover:scale-102 hover:shadow-md"}`}
            onMouseEnter={() => setHoveredTier(tier.tier)}
            onMouseLeave={() => setHoveredTier(null)}
            onClick={() => onSelect?.(tier.tier)}
          >
            {isRecommended && (
              <div className="absolute -top-3 left-1/2 -translate-x-1/2">
                <Badge className={TIER_BADGE_COLORS[tier.tier]}>
                  {Icon} Recommande
                </Badge>
              </div>
            )}

            <CardHeader className="text-center pt-6">
              <CardTitle className="text-lg">{tier.name_fr}</CardTitle>
              <p className="text-xs text-muted-foreground">{tier.description_fr}</p>
            </CardHeader>

            <CardContent className="text-center">
              {/* Price */}
              <div className="mb-4">
                <span className="text-3xl font-bold">
                  {formatCurrency(tier.estimate)}
                </span>
                <div className="text-xs text-muted-foreground mt-1">
                  {formatCurrency(tier.range_low)} - {formatCurrency(tier.range_high)}
                </div>
              </div>

              {/* Materials cost if available */}
              {tier.materials_cost && (
                <div className="text-sm text-muted-foreground mb-4">
                  Materiaux: {formatCurrency(tier.materials_cost)}
                </div>
              )}

              {/* What's included */}
              <ul className="text-left space-y-2 mb-4">
                {tier.includes_fr.map((item, i) => (
                  <li key={i} className="flex items-start gap-2 text-sm">
                    <Check className="h-4 w-4 text-green-600 mt-0.5 flex-shrink-0" />
                    <span>{item}</span>
                  </li>
                ))}
              </ul>

              {/* Select button */}
              <Button
                variant={isRecommended ? "default" : "outline"}
                className={`w-full ${isRecommended ? "bg-[#8B2323] hover:bg-[#6B1A1A]" : ""}`}
                onClick={(e) => {
                  e.stopPropagation();
                  onSelect?.(tier.tier);
                }}
              >
                {isSelected ? "Selectionne" : "Choisir"}
              </Button>
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
}
```

---

### Task 6: Update Estimate Result Display

**Files:**
- Modify: `frontend/src/components/estimate-result.tsx` or create new

**Step 1: Create tier result component**

```tsx
// frontend/src/components/estimateur/estimate-result-tiers.tsx
"use client";

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { TierOptions } from "./tier-options";
import { TieredEstimateResponse, QuoteTier } from "@/types/quote-tiers";
import { useState } from "react";

interface EstimateResultTiersProps {
  result: TieredEstimateResponse;
  onTierSelect?: (tier: QuoteTier) => void;
}

export function EstimateResultTiers({ result, onTierSelect }: EstimateResultTiersProps) {
  const [selectedTier, setSelectedTier] = useState<QuoteTier>("standard");

  const handleSelect = (tier: QuoteTier) => {
    setSelectedTier(tier);
    onTierSelect?.(tier);
  };

  return (
    <div className="space-y-6">
      {/* Confidence indicator */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="text-sm font-medium">
            Confiance: {result.confidence}
          </CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-xs text-muted-foreground">
            Modele: {result.model}
          </p>
        </CardContent>
      </Card>

      {/* Tier options */}
      <div>
        <h3 className="text-lg font-semibold mb-4">Choisissez votre option</h3>
        <TierOptions
          tiers={result.tiers}
          selectedTier={selectedTier}
          onSelect={handleSelect}
        />
      </div>

      {/* Selected tier summary */}
      {selectedTier && (
        <Card className="border-[#8B2323]">
          <CardHeader>
            <CardTitle>Option selectionnee</CardTitle>
          </CardHeader>
          <CardContent>
            {result.tiers
              .filter((t) => t.tier === selectedTier)
              .map((tier) => (
                <div key={tier.tier}>
                  <p className="text-2xl font-bold">
                    {tier.name_fr}: {new Intl.NumberFormat("fr-CA", {
                      style: "currency",
                      currency: "CAD",
                    }).format(tier.estimate)}
                  </p>
                </div>
              ))}
          </CardContent>
        </Card>
      )}

      {/* Reasoning */}
      {result.reasoning && (
        <Card>
          <CardHeader>
            <CardTitle className="text-sm">Raisonnement IA</CardTitle>
          </CardHeader>
          <CardContent>
            <p className="text-sm text-muted-foreground whitespace-pre-wrap">
              {result.reasoning}
            </p>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

---

### Task 7: Add French Translations

**Files:**
- Modify: `frontend/src/lib/i18n/fr.ts`

**Step 1: Add tier translations**

```typescript
export const fr = {
  // ... existing
  tiers: {
    titre: "Options de soumission",
    choisir: "Choisir",
    selectionne: "Selectionne",
    recommande: "Recommande",
    essentiel: "Essentiel",
    standard: "Standard",
    premium: "Premium",
    optionSelectionnee: "Option selectionnee",
    materiaux: "Materiaux",
    inclus: "Inclus",
    garantieBase: "Garantie de base",
    garantieProlongee: "Garantie prolongee",
    garantieVie: "Garantie a vie",
  },
  // ...
};
```

---

### Task 8: Update Database to Store Selected Tier

**Files:**
- Create: `backend/migrations/add_quote_tier.sql`

**Step 1: Create migration**

```sql
-- Migration: Add selected tier to estimates table
-- Purpose: Track which tier the customer selected

-- Add selected_tier column
ALTER TABLE estimates
ADD COLUMN IF NOT EXISTS selected_tier VARCHAR(20);

-- Add tier prices columns for historical tracking
ALTER TABLE estimates
ADD COLUMN IF NOT EXISTS tier_basic_price DECIMAL(12, 2),
ADD COLUMN IF NOT EXISTS tier_standard_price DECIMAL(12, 2),
ADD COLUMN IF NOT EXISTS tier_premium_price DECIMAL(12, 2);

-- Add index for tier analysis
CREATE INDEX IF NOT EXISTS idx_estimates_selected_tier
ON estimates (selected_tier);

-- Add comments
COMMENT ON COLUMN estimates.selected_tier IS 'Customer selected tier: basic, standard, or premium';
COMMENT ON COLUMN estimates.tier_basic_price IS 'Price for basic tier at time of quote';
COMMENT ON COLUMN estimates.tier_standard_price IS 'Price for standard tier at time of quote';
COMMENT ON COLUMN estimates.tier_premium_price IS 'Price for premium tier at time of quote';
```

---

### Task 9: Update Estimate Save Logic

**Files:**
- Modify: `backend/app/routers/estimate.py`

**Step 1: Save tier information**

```python
async def save_estimate(
    request: EstimateRequest,
    result: dict,
    selected_tier: Optional[QuoteTier] = None,
    tiers: Optional[List[TierEstimate]] = None,
):
    """Save estimate with tier information"""
    supabase = get_supabase_client()

    # Build tier price columns
    tier_prices = {}
    if tiers:
        for tier in tiers:
            tier_prices[f"tier_{tier.tier.value}_price"] = tier.estimate

    data = {
        "sqft": request.sqft,
        "category": request.category,
        "ai_estimate": result["estimate"],
        "range_low": result["range_low"],
        "range_high": result["range_high"],
        "confidence": result["confidence"],
        "model": result["model"],
        "complexity": request.get_ml_complexity(),
        "complexity_factors": request.complexity_factors.model_dump() if request.complexity_factors else None,
        "selected_tier": selected_tier.value if selected_tier else None,
        **tier_prices,
    }

    supabase.table("estimates").insert(data).execute()
```

---

### Task 10: Verify and Test

**Step 1: Build verification**

```bash
cd backend && python -m pytest tests/ -v
cd frontend && npm run build
```

**Step 2: API test**

```bash
# Test tiered response
curl -X POST http://localhost:8000/estimate \
  -H "Content-Type: application/json" \
  -d '{
    "sqft": 1500,
    "category": "Elastomere",
    "include_tiers": true
  }' | jq '.tiers'

# Verify three tiers returned
curl -X POST http://localhost:8000/estimate \
  -H "Content-Type: application/json" \
  -d '{"sqft": 1500, "category": "Elastomere"}' | jq '.tiers | length'
# Expected: 3
```

**Step 3: Visual verification**

- Navigate to /estimateur
- Submit an estimate
- Verify 3 tier cards appear (Essentiel, Standard, Premium)
- Verify Standard tier has "Recommande" badge
- Click different tiers and verify selection
- Verify prices scale correctly (Basic < Standard < Premium)

**Step 4: Commit**

```bash
git add -A
git commit -m "feat(tiers): implement Basic/Standard/Premium quote options

- Add tier configuration with multipliers (0.85x, 1.0x, 1.20x)
- Generate three tier estimates per quote
- Create TierOptions component with selection UI
- Mark Standard tier as recommended
- Include tier-specific features/warranty in each option
- Store selected tier and all tier prices in database
- Add French translations for tier labels

Tiers:
- Essentiel (Basic): 0.85x, 5-year warranty
- Standard: 1.0x, 10-year warranty (recommended)
- Premium: 1.20x, lifetime warranty

Closes: Laurent feedback improvement #2"
```

---

## Success Criteria

- [ ] API returns 3 tiers in response (basic, standard, premium)
- [ ] Prices scale correctly: Basic < Standard < Premium
- [ ] Standard tier marked as `is_recommended: true`
- [ ] Each tier includes French description and included features
- [ ] UI displays 3 tier cards with visual differentiation
- [ ] Standard tier has "Recommande" badge
- [ ] Tier selection updates UI and can be saved
- [ ] Database stores selected tier and all tier prices
- [ ] Build passes for both frontend and backend
