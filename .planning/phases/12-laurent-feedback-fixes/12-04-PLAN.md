# 12-04: 6-Factor Complexity System

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Replace the vague 1-100 complexity slider with a concrete 6-factor scoring system (0-56 points) that estimators can evaluate objectively.

**Architecture:** Replace single complexity field with 6 individual factors, calculate total score server-side, update ML features to use total score, update form UI with factor checkboxes/selectors.

**Tech Stack:** FastAPI (Pydantic), TypeScript, React, Zod, shadcn/ui

---

## Context

Laurent's feedback: "The complexity parameter is too vague. My estimators won't know what to put."

### Current System
- Single slider: 1-100 scale
- Subjective interpretation
- Directly passed to ML models

### New System (6 Factors, 0-56 points)

| Factor | Max Points | Description |
|--------|------------|-------------|
| Access difficulty | 0-10 | How hard to reach the roof |
| Roof pitch/slope | 0-8 | Steepness of the roof |
| Penetrations | 0-10 | Chimneys, skylights, vents |
| Material removal | 0-8 | Old material tear-off complexity |
| Safety concerns | 0-10 | Fall hazards, obstacles |
| Timeline constraints | 0-10 | Rush job, weather windows |

**Total: 0-56 points**

---

## Plan

### Task 1: Update Backend Schemas

**Files:**
- Create: `backend/app/schemas/complexity.py`
- Modify: `backend/app/schemas/estimate.py`
- Modify: `backend/app/schemas/materials.py`

**Step 1: Create complexity schema**

Create `backend/app/schemas/complexity.py`:

```python
from pydantic import BaseModel, Field, model_validator
from typing import Optional


class ComplexityFactors(BaseModel):
    """
    6-factor complexity scoring system (0-56 total points).

    Each factor has specific point ranges based on job characteristics.
    Estimators evaluate each factor independently for objective scoring.
    """
    access_difficulty: int = Field(
        default=0,
        ge=0,
        le=10,
        description="How hard to reach the roof (0=ground level, 5=2 story, 10=difficult access)"
    )
    roof_pitch: int = Field(
        default=0,
        ge=0,
        le=8,
        description="Steepness of roof (0=flat, 4=moderate, 8=steep/walkable limits)"
    )
    penetrations: int = Field(
        default=0,
        ge=0,
        le=10,
        description="Number and complexity of penetrations (chimneys, skylights, vents)"
    )
    material_removal: int = Field(
        default=0,
        ge=0,
        le=8,
        description="Old material tear-off complexity (0=none, 4=single layer, 8=multiple layers)"
    )
    safety_concerns: int = Field(
        default=0,
        ge=0,
        le=10,
        description="Fall hazards, obstacles, power lines (0=minimal, 10=significant)"
    )
    timeline_constraints: int = Field(
        default=0,
        ge=0,
        le=10,
        description="Rush job, weather windows, tenant coordination (0=flexible, 10=urgent)"
    )

    @property
    def total_score(self) -> int:
        """Calculate total complexity score (0-56)"""
        return (
            self.access_difficulty +
            self.roof_pitch +
            self.penetrations +
            self.material_removal +
            self.safety_concerns +
            self.timeline_constraints
        )

    @property
    def normalized_score(self) -> float:
        """Normalize to 0-100 scale for ML compatibility"""
        return round(self.total_score / 56 * 100, 1)


class ComplexityInput(BaseModel):
    """
    Input for complexity - accepts either new factors or legacy single value.

    For backwards compatibility, if only `complexity` is provided (1-100),
    it will be used directly. If factors are provided, they take precedence.
    """
    # NEW: Individual factors
    complexity_factors: Optional[ComplexityFactors] = None

    # LEGACY: Single value (for backwards compatibility)
    complexity: Optional[int] = Field(
        default=None,
        ge=1,
        le=100,
        description="Legacy complexity value (1-100). Use complexity_factors instead."
    )

    @model_validator(mode="after")
    def validate_complexity_input(self):
        """Ensure at least one complexity input is provided"""
        if self.complexity_factors is None and self.complexity is None:
            # Default to minimal complexity
            self.complexity_factors = ComplexityFactors()
        return self

    def get_ml_complexity(self) -> int:
        """Get complexity value for ML models (1-100 scale)"""
        if self.complexity_factors:
            # Convert 0-56 to 1-100 scale
            normalized = self.complexity_factors.normalized_score
            return max(1, int(normalized))
        return self.complexity or 10  # Default


# Helper for response
class ComplexityBreakdown(BaseModel):
    """Complexity breakdown for API responses"""
    factors: ComplexityFactors
    total_score: int = Field(description="Sum of all factors (0-56)")
    normalized_score: float = Field(description="Normalized to 0-100 for display")
```

**Step 2: Update estimate.py**

Modify `backend/app/schemas/estimate.py`:

```python
from app.schemas.complexity import ComplexityFactors, ComplexityInput, ComplexityBreakdown

class EstimateRequest(BaseModel):
    """Request body for estimate endpoint"""
    sqft: float = Field(gt=0, le=100000, description="Square footage of roof")
    category: str = Field(description="Job category (e.g., Elastomere, Bardeaux)")
    material_lines: int = Field(default=5, ge=0, le=50)
    labor_lines: int = Field(default=2, ge=0, le=50)
    has_subs: bool = Field(default=False)

    # NEW: Replace single complexity with factors
    complexity_factors: Optional[ComplexityFactors] = None

    # LEGACY: Keep for backwards compatibility
    complexity: Optional[int] = Field(
        default=None,
        ge=1,
        le=100,
        description="Legacy complexity (1-100). Prefer complexity_factors."
    )

    def get_ml_complexity(self) -> int:
        """Get complexity for ML models"""
        if self.complexity_factors:
            return max(1, int(self.complexity_factors.normalized_score))
        return self.complexity or 10


class EstimateResponse(BaseModel):
    """Response from estimate endpoint"""
    estimate: float
    range_low: float
    range_high: float
    confidence: str
    model: str
    similar_cases: List[SimilarCase] = []
    reasoning: Optional[str] = None
    # NEW: Include complexity breakdown in response
    complexity_breakdown: Optional[ComplexityBreakdown] = None
```

**Step 3: Update materials.py similarly**

```python
from app.schemas.complexity import ComplexityFactors

class MaterialEstimateRequest(BaseModel):
    sqft: float = Field(gt=0, le=100000)
    category: str
    # NEW: Replace single complexity with factors
    complexity_factors: Optional[ComplexityFactors] = None
    complexity: Optional[int] = Field(default=None, ge=1, le=100)
    # ... rest of fields

    def get_ml_complexity(self) -> int:
        if self.complexity_factors:
            return max(1, int(self.complexity_factors.normalized_score))
        return self.complexity or 10
```

---

### Task 2: Update Backend Predictor Services

**Files:**
- Modify: `backend/app/services/predictor.py`
- Modify: `backend/app/services/material_predictor.py`
- Modify: `backend/app/services/embeddings.py`

**Step 1: Update predictor.py**

Change complexity parameter handling:

```python
def predict(
    self,
    sqft: float,
    category: str,
    material_lines: int,
    labor_lines: int,
    has_subs: bool,
    complexity: int,  # Now expects normalized 1-100 value
) -> dict:
    """
    Predict price for a roofing job.

    Args:
        complexity: Normalized complexity score (1-100).
                   If using 6-factor system, caller should pass
                   ComplexityFactors.normalized_score.
    """
    # ... existing logic unchanged, complexity used as before
```

**Step 2: Update embeddings.py**

Enhance query text with factor details:

```python
def build_query_text(
    sqft: float,
    category: str,
    complexity: int,
    complexity_factors: Optional[dict] = None,
) -> str:
    """Build query text for CBR similarity search"""
    base = f"toiture {category} {sqft} pieds carres complexite {complexity}"

    # Add factor details if available
    if complexity_factors:
        factors = []
        if complexity_factors.get("access_difficulty", 0) > 5:
            factors.append("acces difficile")
        if complexity_factors.get("roof_pitch", 0) > 4:
            factors.append("pente abrupte")
        if complexity_factors.get("penetrations", 0) > 5:
            factors.append("nombreuses penetrations")
        if complexity_factors.get("safety_concerns", 0) > 5:
            factors.append("risques securite")
        if complexity_factors.get("timeline_constraints", 0) > 5:
            factors.append("delai serre")

        if factors:
            base += " " + " ".join(factors)

    return base
```

---

### Task 3: Update Backend Router

**Files:**
- Modify: `backend/app/routers/estimate.py`

**Step 1: Update estimate endpoint**

```python
@router.post("/", response_model=EstimateResponse)
async def create_estimate(request: EstimateRequest):
    """Create price estimate with 6-factor complexity system"""
    try:
        # Get normalized complexity for ML
        ml_complexity = request.get_ml_complexity()

        # Build complexity breakdown for response
        complexity_breakdown = None
        if request.complexity_factors:
            complexity_breakdown = ComplexityBreakdown(
                factors=request.complexity_factors,
                total_score=request.complexity_factors.total_score,
                normalized_score=request.complexity_factors.normalized_score,
            )

        # Call predictor with normalized complexity
        result = predictor.predict(
            sqft=request.sqft,
            category=request.category,
            material_lines=request.material_lines,
            labor_lines=request.labor_lines,
            has_subs=request.has_subs,
            complexity=ml_complexity,
        )

        # Get similar cases with enhanced query
        query_text = build_query_text(
            sqft=request.sqft,
            category=request.category,
            complexity=ml_complexity,
            complexity_factors=request.complexity_factors.model_dump() if request.complexity_factors else None,
        )
        similar_cases = await get_similar_cases(query_text)

        # Save to database with factor breakdown
        await save_estimate(
            request=request,
            result=result,
            complexity_factors=request.complexity_factors.model_dump() if request.complexity_factors else None,
        )

        return EstimateResponse(
            estimate=result["estimate"],
            range_low=result["range_low"],
            range_high=result["range_high"],
            confidence=result["confidence"],
            model=result["model"],
            similar_cases=similar_cases,
            complexity_breakdown=complexity_breakdown,
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

---

### Task 4: Update Frontend Types

**Files:**
- Create: `frontend/src/types/complexity.ts`
- Modify: `frontend/src/types/estimate.ts`

**Step 1: Create complexity types**

```typescript
// frontend/src/types/complexity.ts

export interface ComplexityFactors {
  access_difficulty: number;  // 0-10
  roof_pitch: number;         // 0-8
  penetrations: number;       // 0-10
  material_removal: number;   // 0-8
  safety_concerns: number;    // 0-10
  timeline_constraints: number; // 0-10
}

export interface ComplexityBreakdown {
  factors: ComplexityFactors;
  total_score: number;       // 0-56
  normalized_score: number;  // 0-100
}

export const COMPLEXITY_FACTOR_CONFIG = {
  access_difficulty: { max: 10, label: "Difficulte d'acces" },
  roof_pitch: { max: 8, label: "Pente du toit" },
  penetrations: { max: 10, label: "Penetrations" },
  material_removal: { max: 8, label: "Retrait materiaux" },
  safety_concerns: { max: 10, label: "Securite" },
  timeline_constraints: { max: 10, label: "Delais" },
} as const;

export const DEFAULT_COMPLEXITY_FACTORS: ComplexityFactors = {
  access_difficulty: 2,
  roof_pitch: 2,
  penetrations: 2,
  material_removal: 2,
  safety_concerns: 2,
  timeline_constraints: 0,
};

export function calculateTotalScore(factors: ComplexityFactors): number {
  return (
    factors.access_difficulty +
    factors.roof_pitch +
    factors.penetrations +
    factors.material_removal +
    factors.safety_concerns +
    factors.timeline_constraints
  );
}

export function calculateNormalizedScore(factors: ComplexityFactors): number {
  return Math.round((calculateTotalScore(factors) / 56) * 100 * 10) / 10;
}
```

---

### Task 5: Update Frontend Form Schema

**Files:**
- Modify: `frontend/src/lib/schemas.ts`

**Step 1: Update Zod schema**

```typescript
import { z } from "zod";

// Complexity factors schema
export const complexityFactorsSchema = z.object({
  access_difficulty: z.number().min(0).max(10).default(2),
  roof_pitch: z.number().min(0).max(8).default(2),
  penetrations: z.number().min(0).max(10).default(2),
  material_removal: z.number().min(0).max(8).default(2),
  safety_concerns: z.number().min(0).max(10).default(2),
  timeline_constraints: z.number().min(0).max(10).default(0),
});

export const estimateFormSchema = z.object({
  sqft: z.number()
    .positive("Square footage must be positive")
    .max(100000, "Square footage cannot exceed 100,000"),
  category: z.string().min(1, "Category is required"),
  material_lines: z.number().min(0).max(50).default(5),
  labor_lines: z.number().min(0).max(50).default(2),
  has_subs: z.boolean().default(false),

  // NEW: Complexity factors (replaces single complexity)
  complexity_factors: complexityFactorsSchema,

  // DEPRECATED: Keep for migration
  // complexity: z.number().min(1).max(100).default(10),
});

export type EstimateFormData = z.infer<typeof estimateFormSchema>;
```

---

### Task 6: Create Complexity Factor Input Component

**Files:**
- Create: `frontend/src/components/estimateur/complexity-factors-input.tsx`

**Step 1: Create the component**

```tsx
// frontend/src/components/estimateur/complexity-factors-input.tsx
"use client";

import { useFormContext } from "react-hook-form";
import { Slider } from "@/components/ui/slider";
import { Label } from "@/components/ui/label";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import {
  ComplexityFactors,
  COMPLEXITY_FACTOR_CONFIG,
  calculateTotalScore,
} from "@/types/complexity";
import { fr } from "@/lib/i18n/fr";

interface FactorSliderProps {
  name: keyof ComplexityFactors;
  value: number;
  onChange: (value: number) => void;
}

const FACTOR_LABELS: Record<keyof ComplexityFactors, { label: string; hints: string[] }> = {
  access_difficulty: {
    label: "Difficulte d'acces",
    hints: ["Niveau sol", "1 etage", "2 etages", "Echelle longue", "Tres difficile"],
  },
  roof_pitch: {
    label: "Pente du toit",
    hints: ["Plat", "Faible", "Moderee", "Abrupte"],
  },
  penetrations: {
    label: "Penetrations (cheminees, puits de lumiere)",
    hints: ["Aucune", "1-2", "3-5", "6+", "Complexe"],
  },
  material_removal: {
    label: "Retrait de materiaux existants",
    hints: ["Aucun", "Couche simple", "Double couche", "Multiple"],
  },
  safety_concerns: {
    label: "Preoccupations de securite",
    hints: ["Minimal", "Faible", "Modere", "Eleve", "Significatif"],
  },
  timeline_constraints: {
    label: "Contraintes de delai",
    hints: ["Flexible", "Normal", "Serre", "Urgent", "Critique"],
  },
};

function FactorSlider({ name, value, onChange }: FactorSliderProps) {
  const config = COMPLEXITY_FACTOR_CONFIG[name];
  const labels = FACTOR_LABELS[name];

  return (
    <div className="space-y-2">
      <div className="flex justify-between items-center">
        <Label className="text-sm font-medium">{labels.label}</Label>
        <Badge variant="outline">{value} / {config.max}</Badge>
      </div>
      <Slider
        value={[value]}
        onValueChange={([v]) => onChange(v)}
        min={0}
        max={config.max}
        step={1}
        className="w-full"
      />
      <div className="flex justify-between text-xs text-muted-foreground">
        <span>{labels.hints[0]}</span>
        <span>{labels.hints[labels.hints.length - 1]}</span>
      </div>
    </div>
  );
}

export function ComplexityFactorsInput() {
  const { watch, setValue } = useFormContext();
  const factors = watch("complexity_factors") as ComplexityFactors;

  const totalScore = calculateTotalScore(factors);
  const maxScore = 56;
  const percentage = Math.round((totalScore / maxScore) * 100);

  const getScoreColor = () => {
    if (percentage < 30) return "text-green-600";
    if (percentage < 60) return "text-amber-600";
    return "text-red-600";
  };

  const handleFactorChange = (name: keyof ComplexityFactors, value: number) => {
    setValue(`complexity_factors.${name}`, value, { shouldValidate: true });
  };

  return (
    <Card>
      <CardHeader className="pb-3">
        <div className="flex justify-between items-center">
          <CardTitle className="text-base">Facteurs de Complexite</CardTitle>
          <div className="text-right">
            <span className={`text-2xl font-bold ${getScoreColor()}`}>
              {totalScore}
            </span>
            <span className="text-sm text-muted-foreground"> / {maxScore}</span>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-6">
        {(Object.keys(COMPLEXITY_FACTOR_CONFIG) as (keyof ComplexityFactors)[]).map((key) => (
          <FactorSlider
            key={key}
            name={key}
            value={factors[key]}
            onChange={(v) => handleFactorChange(key, v)}
          />
        ))}
      </CardContent>
    </Card>
  );
}
```

---

### Task 7: Update Estimate Form

**Files:**
- Modify: `frontend/src/components/estimate-form.tsx`

**Step 1: Replace complexity slider with factors component**

```tsx
import { ComplexityFactorsInput } from "@/components/estimateur/complexity-factors-input";
import { DEFAULT_COMPLEXITY_FACTORS } from "@/types/complexity";

// Update form defaults
const form = useForm<EstimateFormData>({
  resolver: zodResolver(estimateFormSchema),
  defaultValues: {
    sqft: 1500,
    category: "",
    material_lines: 5,
    labor_lines: 2,
    has_subs: false,
    complexity_factors: DEFAULT_COMPLEXITY_FACTORS,
  },
});

// In JSX, replace the complexity slider with:
<ComplexityFactorsInput />

// Remove the old complexity slider section
```

---

### Task 8: Add French Translations

**Files:**
- Modify: `frontend/src/lib/i18n/fr.ts`

**Step 1: Add complexity translations**

```typescript
export const fr = {
  // ... existing
  complexity: {
    titre: "Facteurs de Complexite",
    accesDifficulte: "Difficulte d'acces",
    penteToit: "Pente du toit",
    penetrations: "Penetrations",
    retraitMateriaux: "Retrait de materiaux",
    securite: "Preoccupations de securite",
    delais: "Contraintes de delai",
    score: "Score",
    sur: "sur",
    simple: "Simple",
    complexe: "Complexe",
  },
  // ...
};
```

---

### Task 9: Update Database Migration

**Files:**
- Create: `backend/migrations/add_complexity_factors.sql`

**Step 1: Add migration for storing factor breakdown**

```sql
-- Migration: Add complexity factors to estimates table
-- Purpose: Store individual complexity factors for analysis

-- Add complexity_factors JSONB column
ALTER TABLE estimates
ADD COLUMN IF NOT EXISTS complexity_factors JSONB;

-- Add index for factor queries
CREATE INDEX IF NOT EXISTS idx_estimates_complexity_factors
ON estimates USING gin(complexity_factors);

-- Add comment
COMMENT ON COLUMN estimates.complexity_factors IS 'JSONB breakdown of 6 complexity factors (access_difficulty, roof_pitch, penetrations, material_removal, safety_concerns, timeline_constraints)';
```

---

### Task 10: Verify and Test

**Step 1: Build verification**

```bash
cd backend && python -m pytest tests/ -v
cd frontend && npm run build
```

**Step 2: API test with new format**

```bash
# Test with new complexity factors
curl -X POST http://localhost:8000/estimate \
  -H "Content-Type: application/json" \
  -d '{
    "sqft": 1500,
    "category": "Elastomere",
    "material_lines": 5,
    "labor_lines": 2,
    "has_subs": false,
    "complexity_factors": {
      "access_difficulty": 5,
      "roof_pitch": 3,
      "penetrations": 4,
      "material_removal": 2,
      "safety_concerns": 3,
      "timeline_constraints": 2
    }
  }' | jq '.complexity_breakdown'

# Test backwards compatibility with legacy format
curl -X POST http://localhost:8000/estimate \
  -H "Content-Type: application/json" \
  -d '{
    "sqft": 1500,
    "category": "Elastomere",
    "complexity": 50
  }'
```

**Step 3: Visual verification**

- Navigate to /estimateur
- Verify 6 factor sliders appear
- Adjust factors and verify total score updates
- Submit and verify response includes complexity_breakdown

**Step 4: Commit**

```bash
git add -A
git commit -m "feat(complexity): implement 6-factor complexity scoring system

BREAKING CHANGE: complexity field deprecated, use complexity_factors

- Add 6 complexity factors: access, pitch, penetrations, removal, safety, timeline
- Calculate total score (0-56) and normalize to 0-100 for ML
- Maintain backwards compatibility with legacy complexity field
- Create ComplexityFactorsInput component with 6 sliders
- Update estimate form to use new component
- Store factor breakdown in database for analysis
- Enhance CBR query text with factor keywords

Factors:
- access_difficulty (0-10): How hard to reach the roof
- roof_pitch (0-8): Steepness of the roof
- penetrations (0-10): Chimneys, skylights, vents
- material_removal (0-8): Old material tear-off
- safety_concerns (0-10): Fall hazards, obstacles
- timeline_constraints (0-10): Rush job, weather

Closes: Laurent feedback improvement #1"
```

---

## Success Criteria

- [ ] API accepts `complexity_factors` with 6 individual factor values
- [ ] API maintains backwards compatibility with legacy `complexity` field
- [ ] ML models receive normalized complexity (1-100 scale)
- [ ] Form displays 6 factor sliders with labels and hints
- [ ] Total score (0-56) displays and updates in real-time
- [ ] API response includes `complexity_breakdown` with factors
- [ ] Database stores factor breakdown in JSONB column
- [ ] Build passes for both frontend and backend
